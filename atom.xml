<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>文若君</title>
  
  <subtitle>记录一个程序员编程技术成长的知识分享博客</subtitle>
  <link href="https://isbut.cn/atom.xml" rel="self"/>
  
  <link href="https://isbut.cn/"/>
  <updated>2021-03-22T13:19:36.795Z</updated>
  <id>https://isbut.cn/</id>
  
  <author>
    <name>Ryan_Coder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于XML注入的Spring手写实现笔记</title>
    <link href="https://isbut.cn/posts/8843/"/>
    <id>https://isbut.cn/posts/8843/</id>
    <published>2021-03-22T13:19:38.754Z</published>
    <updated>2021-03-22T13:19:36.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring手写实现笔记"><a href="#Spring手写实现笔记" class="headerlink" title="Spring手写实现笔记"></a>Spring手写实现笔记</h1><blockquote><p>本篇文章并不是教你如何基于XML注解实现Spring，仅仅是本人手写实现Spring XML注解注入的时候一点心得，如果发现有错误，还望告知，github链接：<a href="https://github.com/laowenruo/Spring-">https://github.com/laowenruo/Spring-</a>  （目前仅仅实现了XML，之后还会实现其他方式）</p></blockquote><h2 id="基于XML注解实现"><a href="#基于XML注解实现" class="headerlink" title="基于XML注解实现"></a>基于XML注解实现</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p>IOC的作用就是把每个bean之间的关系交给第三方容器进行管理，bean的初始化等交给容器处理，即控制反转</p></li><li><p>所有配置文件只要是配置了全路径，我们就可以理解为其是反射得到的（如：spring.xml中配置的bean中的class属性）</p></li><li><p>SpringIOC的XML版本采用的是dom4j+反射技术实现的</p></li><li><p>反射的构造对象，肯定会走无参构造函数的。（无论构造函数是否私有）</p></li></ul><h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><h4 id="定义ApplicationContext"><a href="#定义ApplicationContext" class="headerlink" title="定义ApplicationContext"></a>定义ApplicationContext</h4><blockquote><p>因为我们使用Spring的Xml注入的时候，我们是通过ApplicationContext，即应用上下文来加载Xml后获取对象的，所以我们第一步先定义一个ApplicaitionContext的接口（为什么要定义成接口，主要是为了类的设计–单一职责原则）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类名获取对象，即ByClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名字获取对象，即ByName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义AbstractApplicationContext"><a href="#定义AbstractApplicationContext" class="headerlink" title="定义AbstractApplicationContext"></a>定义AbstractApplicationContext</h4><blockquote><p>这里实现得就有点像代理模式了，并且也要引入一个BeanFactory，因为我们获取的对象都在BeanFatory里面构造，说到这里，我们可能会想到了部分原理，即ApplicationContext传入一个XML文件—-XML文件转换为Resource流—–初始化工厂——读取Resource流中配置信息到BeanDefinition—–注册到工厂类—-由之前的工厂类创建Bean对象，并且设置各种属性等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> BeanFactory beanFactory;  <span class="comment">//工厂类，实现了工厂模式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义BeanDefinition"><a href="#定义BeanDefinition" class="headerlink" title="定义BeanDefinition"></a>定义BeanDefinition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object bean;  <span class="comment">//实例化后的对象</span></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line">    <span class="keyword">private</span> String beanClassName;</span><br><span class="line">    <span class="keyword">private</span> Boolean singleton; <span class="comment">//是否为单例模式</span></span><br><span class="line">    <span class="keyword">private</span> PropertyValues propertyValues;   <span class="comment">//这个也就是属性的键值对了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClassName = beanClassName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanClass = Class.forName(beanClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyValues == <span class="keyword">null</span>) &#123;</span><br><span class="line">            propertyValues = <span class="keyword">new</span> PropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSingleton</span><span class="params">(Boolean singleton)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.singleton = singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义ClassPathXmlApplicationContext"><a href="#定义ClassPathXmlApplicationContext" class="headerlink" title="定义ClassPathXmlApplicationContext"></a>定义ClassPathXmlApplicationContext</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">            AbstractBeanFactory beanFactory = obtainBeanFactory();</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanFactory.populateBeans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractBeanFactory <span class="title">obtainBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(location);</span><br><span class="line">        AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowiredCapableBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : beanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义XmlBeanDefinitionReader"><a href="#定义XmlBeanDefinitionReader" class="headerlink" title="定义XmlBeanDefinitionReader"></a>定义XmlBeanDefinitionReader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XML配置文件形式的Bean定义读取类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ziyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder documentBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document document = documentBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析xml document并注册bean</span></span><br><span class="line">        registerBeanDefinitions(document);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document document)</span> </span>&#123;</span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        <span class="comment">// 从文件根递归解析</span></span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        NodeList nodeList = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i ++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                processBeanDefinition((Element) node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        String name = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String className = ele.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ele.hasAttribute(<span class="string">&quot;scope&quot;</span>) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(ele.getAttribute(<span class="string">&quot;scope&quot;</span>))) &#123;</span><br><span class="line">            singleton = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processProperty(ele, beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        beanDefinition.setSingleton(singleton);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i ++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyEle.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; must specify a ref or value&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ClassPathXmlApplication传入xml文件的路径，并且在构造函数中调用refresh方法</li><li>在这个方法中由AbstractBeanFactory定义了一个工厂类，并且调用了obtainBeanFatcory方法，在方法中调用了XmlBeanDefinitionReader类，这个类将XML转换成Resource流，并且读取了其中的key和value值，value值就是BeanDefinition</li><li>由AutowiredCapableBeanFactory（自动装配工厂类）定义一个工厂，将上述的Key和Value注册到工厂中并且返回到上面定义的工厂类，即将BeanDefinition注册到工厂类中</li><li>最后调用prepareBeanFactory方法，层层嵌套后是调用doCreateBean方法，将对象中的属性注入对象中，返回Bean到工厂中，此时BeanDefinition中的bean中就是一个实例化后、具有属性设置的对象了</li><li>之后，你就可以通过ByName或者ByClass来获取你的对象了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring手写实现笔记&quot;&gt;&lt;a href=&quot;#Spring手写实现笔记&quot; class=&quot;headerlink&quot; title=&quot;Spring手写实现笔记&quot;&gt;&lt;/a&gt;Spring手写实现笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章并不是教你如何基于XML注</summary>
      
    
    
    
    <category term="java基础" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="框架" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="java基础" scheme="https://isbut.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="框架" scheme="https://isbut.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>关于Java集合的部分复习知识点整理</title>
    <link href="https://isbut.cn/posts/1/"/>
    <id>https://isbut.cn/posts/1/</id>
    <published>2021-03-21T12:34:20.840Z</published>
    <updated>2021-03-21T12:43:29.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Java集合的部分复习知识点整理"><a href="#关于Java集合的部分复习知识点整理" class="headerlink" title="关于Java集合的部分复习知识点整理"></a>关于Java集合的部分复习知识点整理</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ol><li><p>ArrayList本质上继承了AbstractList，而AbstractList则是继承了Collection集合类，并且Arraylist是实现了List的接口</p></li><li><p>ArrayList初始的容量，DEFAULT_CAPACITY = 10，即初始容量为10，但初始化对象的时候可以传入你自定义的容量最大容量为Interger.MaxValue-8</p></li><li><p>ArrayList的默认元素存储，是一个Object[]数组</p></li><li><p>ArrayList源码里面存在一个ensureCapacity的方法，用来确认数组的容量是否需要扩容，扩容的时候采用的是Arrays.Copyof的方法，复制元素到一个新的数组</p></li><li><p>关于ArrayList的扩容机制，达到了定义容量（不传入容量的话，即为默认容量）的时候，会动态扩容1.5倍，也是采用上述的复制方法</p></li><li><p>ArrayList其实是存在手动缩容的方法的，在源码中有叫做 trimToSize()的方法，一般是手动调用的</p></li><li><p>ArrayList中删除元素的Remove方法其实也是采用arraycopy()的方法来进行元素的移动，本质跟数组差不多</p></li><li><p>ArrayList是线程不安全的，里面没有实现线程安全的保障，多线程在访问的时候，实现的自动扩容也是造成线程不安全的一部分原因。相反，常见的Vector基本上是靠synchronized来实现线程安全的</p></li></ol><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li><p>HashMap实现了Map接口，初始容量为16，最大容量为1 &lt;&lt; 30，默认加载因子为0.75，如果自己传入初始值K，则容量为大于K的2次方整数，例如：传入10的话，则容量为16</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0bd617d78eb7474f3ff0f42d4887f16a.png"></p></li><li><p>HashMap的插入原理</p><p><img src="https://img-blog.csdnimg.cn/img_convert/af26da061524b4f0a182cf0b2749e1ce.png"></p></li><li><p>在JDK1.8之前，HashMap使用数组+链表实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间，红黑树转链表的阈值是6</p><ul><li>hash函数是通过拿到key的hashcode，然后让hashcode的高16位和低16位进行异或操作，这样设计的原因是尽可能地减小hash碰撞，其二是位运算比较高效</li></ul></li><li><p>hashmap如果采用头插法的话，在多线程的情况下会产生环，并且hashmap在多线程下也是不安全的，在JDK8之前的话，是先判断扩容再插入的，而JDK8之后则是先插入再判断是否需要扩容，扩容为扩容到原数组大小的2倍</p><ul><li><p>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小</p></li><li><p>链表转红黑树，并不是达到8个Node节点的阈值就进行转换，而是要判断一下整个数据结构中的Node数量是否大于64，大于才会转，小于就会用扩容数组的方式代替红黑树的转换</p></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li></ul><p>Java中有HashTable、Collections.synchronizedMap、以及ConcurrentHashMap可以实现线程安全的Map。</p><ol><li>HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大；</li><li>Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法内通过对象锁实现；</li><li>ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于Java集合的部分复习知识点整理&quot;&gt;&lt;a href=&quot;#关于Java集合的部分复习知识点整理&quot; class=&quot;headerlink&quot; title=&quot;关于Java集合的部分复习知识点整理&quot;&gt;&lt;/a&gt;关于Java集合的部分复习知识点整理&lt;/h1&gt;&lt;h2 id=&quot;A</summary>
      
    
    
    
    <category term="java基础" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java基础" scheme="https://isbut.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之抽象工厂模式</title>
    <link href="https://isbut.cn/posts/59550/"/>
    <id>https://isbut.cn/posts/59550/</id>
    <published>2021-03-14T13:44:24.807Z</published>
    <updated>2021-03-14T14:21:12.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><pre><code>我们都知道设计模式有五大原则</code></pre><ol><li>单一职责原则：实现类要职责单一。</li><li>开闭原则：对扩展开放，对修改关闭。</li><li>里氏替换原则：不要破坏继承体系。</li><li>接口隔离原则：设计接口的时候要精简单一。</li><li>依赖倒置原则：要面向接口编程。</li></ol><blockquote><p>了解完设计模式的五大原则后，因为简单工厂模式即是利用工厂来返回所需的实例化对象，而工厂方法则是利用实现接口后的对象工厂来返回实例化的对象。而前两种都有一定的缺点</p></blockquote><ol><li>简单工厂模式（静态工厂模式）：违反了开闭原则，耦合度较高</li><li>工厂方法模式：属于多态工厂模式，定义创建产品对象的工厂接口，将实际创建工作推迟到子类中，但调用类出现创建对象逻辑，违背单一职责原则，增加了项目开发的复杂度<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h2 id="产品接口和实现类"><a href="#产品接口和实现类" class="headerlink" title="产品接口和实现类"></a>产品接口和实现类</h2></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;  <span class="comment">//举例引擎，其他的省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighEndEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高端发动机，启动快&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowEndEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;低端发动机，启动慢&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂接口"><a href="#工厂接口" class="headerlink" title="工厂接口"></a>工厂接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Tyre <span class="title">createTyre</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Seat <span class="title">createSeat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂实现类"><a href="#工厂实现类" class="headerlink" title="工厂实现类"></a>工厂实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighEndCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HighEndEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HighEndTyre();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HighEndSeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowEndCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LowEndEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LowEndTyre();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LowEndSeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CarFactory cf = <span class="keyword">new</span> HighEndCarFactory();</span><br><span class="line">        </span><br><span class="line">        Engine engine = cf.createEngine();</span><br><span class="line">        </span><br><span class="line">        Tyre tyre = cf.createTyre();</span><br><span class="line">        </span><br><span class="line">        Seat seat = cf.createSeat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理解，高端工厂类只制造高端产品，例如高端引擎、高端轮胎以及高端座椅等，当产品族中新增几个产品，只需创建产品类以及在对应的工厂类中添加对应的方法即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用设计模式时，很难遵循五大原则和一大法则。我们使用设计模式是为了让代码具有可复用性、可扩展性和灵活性，不能一味地守着这几个规定，从而限制自己对编程的想象和发挥。因此，需要使用怎样的设计模式还得根据项目的实际需求来衡量选择。<br>这就跟我们的数据库三大范式一样，我们很难一样地遵循三大范式，有时候为了性能以及查询之类的效率，会增加点数据冗余。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;我们都知道设计模式有五大原则&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;单一职责原则：实现类要职责单一。&lt;/li&gt;
&lt;li&gt;开闭原则：对扩展开放，对修改关闭。&lt;/li&gt;
&lt;li&gt;里氏替换原则：不要破坏继承体系。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="java基础" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="设计模式" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java基础" scheme="https://isbut.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="设计模式" scheme="https://isbut.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化serializabel的作用及应用</title>
    <link href="https://isbut.cn/posts/43483/"/>
    <id>https://isbut.cn/posts/43483/</id>
    <published>2021-03-10T13:00:44.356Z</published>
    <updated>2021-03-21T12:46:40.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天了解了RPC调用的一些基本原理和介绍，对于在远程调用方法的时候对象的传输中序列化serializabel的作用也更加清晰，故记录下</p></blockquote><p>很多人觉得自己写得 Java 代码中，新建的 pojo 对象要实现序列化是为了要保存到硬盘上，其实呢，实现序列化和保存到硬盘上没有必然的关系。<br><img src="https://img-blog.csdnimg.cn/20210310201837920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="调用过程"></p><ul><li>很多人在初学序列化操作的时候，一般都是理解为对象通过序列化保存在磁盘上的字节流文件，后又通过字节流反向读取为对象。 </li><li>我们将 Java对象转换成公共的格式叫做序列化，将公共的格式转换成对象叫做反序列化。保存到磁盘只是序列化的一种表现形式。</li></ul><h2 id="实现序列化的原因"><a href="#实现序列化的原因" class="headerlink" title="实现序列化的原因"></a>实现序列化的原因</h2><ul><li>将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本</li><li>将对象从一个应用程序域发送至另一个应用程序域。实现serializabel接口的作用是就是可以把对象存到字节流，然后可以恢复，而网络传输的基础则是字节流，故既可以远程传输，又可以本地化恢复。（Ps:不实现序列化接口得话，服务器并不能识别其为对象类型，这是关键）<h2 id="什么时候需要序列化"><a href="#什么时候需要序列化" class="headerlink" title="什么时候需要序列化"></a>什么时候需要序列化</h2></li><li>当你想用套接字在网络上传送对象的时候；</li><li>当你想把的内存中的对象写入到硬盘的时候；</li><li>当你想通过RMI传输对象的时候；（远程调用方法，如RPC）<h2 id="Json和serializabel对比"><a href="#Json和serializabel对比" class="headerlink" title="Json和serializabel对比"></a>Json和serializabel对比</h2></li><li>长度方面，Json比serializabel小</li><li>速度方面，Json比serializabel快，但序列化算法好像并不止一种</li><li>表示方面，Json一般表示字符串，如果前端要将其处理为对象，需要额外的处理，而serializabel则直接恢复</li></ul><h2 id="Json和serializabel选择"><a href="#Json和serializabel选择" class="headerlink" title="Json和serializabel选择"></a>Json和serializabel选择</h2><ul><li><p> 序列化使用serialize，特别是对象的存储。这是其存在的意义。</p></li><li><p>与对象无关的数据存储可以使用json，如包含大量数字的数组等。只是当遇到这种情况，我们需要做的可能是重构数据库了。</p></li><li><p>数据交换时使用JSON，这也是其定义所在。</p></li><li><p>目前JSON是能用于UTF-8编码的数据</p><h2 id="Java序列化的相关知识点"><a href="#Java序列化的相关知识点" class="headerlink" title="Java序列化的相关知识点"></a>Java序列化的相关知识点</h2></li><li><p>Java序列化有两种方式，一种是实现Serializable接口。</p></li><li><p>另一种是实现Exteranlizable接口。而实现Exteranlizable接口的时候，我们需要重写writeExternal和readExternal方法，它的效率比Serializable高一些，并且可以决定哪些属性需要序列化（即使是transient修饰的），但是对大量对象，或者重复对象，则效率低。</p></li><li><p>静态变量是不会被序列化的，即使没有transient关键字修饰<br><img src="https://img-blog.csdnimg.cn/20210310204621342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="serializabel的例子"><a href="#serializabel的例子" class="headerlink" title="serializabel的例子"></a>serializabel的例子</h2><p>对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span>  //实现了序列化</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;  <span class="comment">//transient等下再讲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mailing a check to &quot;</span> + name</span><br><span class="line">                + <span class="string">&quot; &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">        e.name = <span class="string">&quot;Reyan Ali&quot;</span>;</span><br><span class="line">        e.address = <span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;</span><br><span class="line">        e.SSN = <span class="number">11122333</span>;</span><br><span class="line">        e.number = <span class="number">101</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            FileOutputStream fileOut =</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Ryan\\Desktop\\obj.ser&quot;</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">            out.writeObject(e);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.printf(<span class="string">&quot;Serialized data is saved in obj.ser&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">        &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Ryan\\Desktop\\obj.ser&quot;</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            e = (Employee) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">        &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Deserialized Employee...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address);</span><br><span class="line">        System.out.println(<span class="string">&quot;SSN: &quot;</span> + e.SSN);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number: &quot;</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>彩蛋<br><img src="https://img-blog.csdnimg.cn/2021031020524156.png" alt="在这里插入图片描述"><br>transient关键字修饰的变量反序列失败噢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天了解了RPC调用的一些基本原理和介绍，对于在远程调用方法的时候对象的传输中序列化serializabel的作用也更加清晰，故记录下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多人觉得自己写得 Java 代码中，新建的 pojo 对象要实现序列</summary>
      
    
    
    
    <category term="java基础" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java基础" scheme="https://isbut.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>清空github仓库,而不是删除重新创建.</title>
    <link href="https://isbut.cn/posts/63313/"/>
    <id>https://isbut.cn/posts/63313/</id>
    <published>2021-03-08T02:45:54.179Z</published>
    <updated>2021-03-08T03:06:24.918Z</updated>
    
    <content type="html"><![CDATA[<p>今天由于想清空github仓库重新来过，后来不知道怎么解决，于是上网找了资料，顺便发个博文</p><p>– Remove the history from</p><p>（从中删除历史记录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure><p>– recreate the repos from the current content only</p><p>（仅从当前内容重新创建存储库）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure><p>– push to the github remote repos ensuring you overwrite history</p><p>（推送到你的远程仓库，以确保覆盖您的历史记录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:&lt;YOUR ACCOUNT&gt;&#x2F;&lt;YOUR REPOS&gt;.git</span><br><span class="line">git push -u --force origin master</span><br></pre></td></tr></table></figure><blockquote><p>来源: <a href="https://gist.github.com/stephenhardy/5470814">https://gist.github.com/stephenhardy/5470814</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天由于想清空github仓库重新来过，后来不知道怎么解决，于是上网找了资料，顺便发个博文&lt;/p&gt;
&lt;p&gt;– Remove the history from&lt;/p&gt;
&lt;p&gt;（从中删除历史记录）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="工具" scheme="https://isbut.cn/categories/tools/"/>
    
    
    <category term="工具" scheme="https://isbut.cn/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>SSM小书城整合，新手框架整合练习</title>
    <link href="https://isbut.cn/posts/2860/"/>
    <id>https://isbut.cn/posts/2860/</id>
    <published>2021-03-08T02:41:46.101Z</published>
    <updated>2021-03-21T12:46:15.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM小书城整合，新手框架整合练习"><a href="#SSM小书城整合，新手框架整合练习" class="headerlink" title="SSM小书城整合，新手框架整合练习"></a>SSM小书城整合，新手框架整合练习</h1><p>所有文件都在github（<a href="https://github.com/laowenruo/SSM-library%EF%BC%89">https://github.com/laowenruo/SSM-library）</a></p><p>本项目主要用于用于新手刚入门Spring，Mybatis,SpringMVC框架后，需要小练手整合一下，熟悉完框架之后，还是可以深入学习一下或者学下Springboot等内容(如果本项目对您有帮助，请 watch、star、fork 素质三连一波，鼓励一下作者，谢谢）<br><img src="https://img-blog.csdnimg.cn/20210308102533174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210308102533134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h2><ul><li>创建一个存放书籍数据的数据库表</li><li>文件为数据库.sql</li></ul><h2 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h2><ul><li>新建一Maven项目！ 添加web的支持</li><li>导入相关的pom依赖！</li><li>文件为pom.xml</li><li>文件为Maven资源过滤设置,静态资源导出问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;resources&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>建立基本结构和配置框架！</li></ul><h2 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h2><ul><li><p>数据库配置文件 database.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line"># &amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;123456</span><br></pre></td></tr></table></figure></li><li><p>编写MyBatis的核心配置文件  mybatis-config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;typeAliases&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;mapper resource&#x3D;&quot;com&#x2F;kuang&#x2F;dao&#x2F;BookMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写数据库对应的实体类 com.pojo.Books，可使用lombok插件！</p></li><li><p>编写Dao层的 Mapper接口！</p></li><li><p>编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p></li><li><p>编写Service层的接口和实现类</p></li></ul><h2 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h2><ul><li><p>配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；</p></li><li><p>我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p></li><li><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 配置整合mybatis --&gt;   &lt;!-- 1.关联数据库文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;   &lt;!-- 2.数据库连接池 --&gt;   &lt;!--数据库连接池       dbcp 半自动化操作 不能自动连接       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）   --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;       &lt;!-- 配置连接池属性 --&gt;       &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;       &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;       &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;       &lt;!-- c3p0连接池的私有属性 --&gt;       &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;       &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;       &lt;!-- 关闭连接后不自动commit --&gt;       &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;       &lt;!-- 获取连接超时时间 --&gt;       &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;       &lt;!-- 当获取连接失败重试次数 --&gt;       &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;       &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;   &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;   &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;       &lt;!-- 注入sqlSessionFactory --&gt;       &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;       &lt;!-- 给出需要扫描Dao接口包 --&gt;       &lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.dao&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Spring整合service层，Spring-service.xml文件编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 扫描service相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.service&quot; /&gt;   &lt;!--BookServiceImpl注入到IOC容器中--&gt;   &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.service.BookServiceImpl&quot;&gt;       &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 配置事务管理器 --&gt;   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;   &lt;/bean&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## SpringMVC层</span><br><span class="line"></span><br><span class="line">- web.xml编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;        version=&quot;4.0&quot;&gt;   &lt;!--DispatcherServlet--&gt;   &lt;servlet&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;           &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;       &lt;/init-param&gt;       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;   &lt;/servlet&gt;   &lt;servlet-mapping&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;   &lt;/servlet-mapping&gt;   &lt;!--encodingFilter--&gt;   &lt;filter&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;filter-class&gt;          org.springframework.web.filter.CharacterEncodingFilter       &lt;/filter-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;/param-name&gt;           &lt;param-value&gt;utf-8&lt;/param-value&gt;       &lt;/init-param&gt;   &lt;/filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   &lt;/filter-mapping&gt;   &lt;!--Session过期时间--&gt;   &lt;session-config&gt;       &lt;session-timeout&gt;15&lt;/session-timeout&gt;   &lt;/session-config&gt;&lt;/web-app&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- spring-mvc.xml编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/mvc   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;   &lt;!-- 配置SpringMVC --&gt;   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;   &lt;mvc:annotation-driven /&gt;   &lt;!-- 2.静态资源默认servlet配置--&gt;   &lt;mvc:default-servlet-handler/&gt;   &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;       &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;   &lt;/bean&gt;   &lt;!-- 4.扫描web相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 最后的最后，大整合</span><br><span class="line"></span><br><span class="line">- applicationContext.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;   &lt;import resource=&quot;spring-dao.xml&quot;/&gt;   &lt;import resource=&quot;spring-service.xml&quot;/&gt;   &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt;</code></pre></li></ul><h3 id="接下来就是自由的编写Controller以及视图层了，这里就不写了"><a href="#接下来就是自由的编写Controller以及视图层了，这里就不写了" class="headerlink" title="接下来就是自由的编写Controller以及视图层了，这里就不写了"></a>接下来就是自由的编写Controller以及视图层了，这里就不写了</h3><ul><li>本项目主要是基于狂神说的SpringMVC整合书城项目编写，额外的就是试了下PageHelper的插件，实现了分页</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSM小书城整合，新手框架整合练习&quot;&gt;&lt;a href=&quot;#SSM小书城整合，新手框架整合练习&quot; class=&quot;headerlink&quot; title=&quot;SSM小书城整合，新手框架整合练习&quot;&gt;&lt;/a&gt;SSM小书城整合，新手框架整合练习&lt;/h1&gt;&lt;p&gt;所有文件都在gith</summary>
      
    
    
    
    <category term="java基础" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="框架" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="java基础" scheme="https://isbut.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="框架" scheme="https://isbut.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java实现TCP/UDP编程</title>
    <link href="https://isbut.cn/posts/8411/"/>
    <id>https://isbut.cn/posts/8411/</id>
    <published>2021-03-02T15:50:42.270Z</published>
    <updated>2021-03-02T16:10:56.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP在计网中的位置十分重要，很多协议的运行都是以TCP为基础来运行的，虽然TCP的开销比UDP开销大，但其实现的可靠性交付是一大特点，其还具有流量控制、拥塞控制等特性，在面试中也少不了谈其三次握手、四次挥手以及其他问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class LengthCalculator extends  Thread&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line">    public LengthCalculator(Socket socket)&#123;</span><br><span class="line">        this.socket&#x3D;socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            OutputStream os &#x3D;socket.getOutputStream();</span><br><span class="line">            InputStream is &#x3D;socket.getInputStream();</span><br><span class="line">            int ch&#x3D;0;</span><br><span class="line">            byte[] buff &#x3D;new byte[1024];</span><br><span class="line">            ch&#x3D;is.read(buff);</span><br><span class="line">            String content &#x3D;new String(buff,0,ch);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">            os.write(String.valueOf(content.length()).getBytes());</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket&#x3D;new Socket(&quot;127.0.0.1&quot;,65000);</span><br><span class="line">        OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line">        InputStream in &#x3D; socket.getInputStream();</span><br><span class="line">        out.write(&quot;Hello World!&quot;.getBytes());</span><br><span class="line">        int ch&#x3D;0;</span><br><span class="line">        byte[] bytes&#x3D;new byte[1024];</span><br><span class="line">        ch&#x3D;in.read(bytes);</span><br><span class="line">        String content&#x3D;new String(bytes,0,ch);</span><br><span class="line">        System.out.println(&quot;接收到内容content:&quot;+content);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket ss &#x3D;new ServerSocket(65000);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Socket socket&#x3D;ss.accept();</span><br><span class="line">            new LengthCalculator(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP是数据报传输协议，其可传输的大小取决于数据报的大小，不像TCP协议一样受到MTU最大传输的限制，也不用像TCP一样实现报文切片等特性进行传输，但UDP的主要传输速率取决于双方的带宽，且不提供可靠性交付。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class UDPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket();</span><br><span class="line">        byte[] buf &#x3D;&quot;hello world&quot;.getBytes();</span><br><span class="line">        &#x2F;&#x2F;将IP封装为InetAddress对象</span><br><span class="line">        InetAddress address &#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);</span><br><span class="line">        &#x2F;&#x2F;将要发送数据封装成DatagramPacket对象，填写上ip地址与端口号</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buf,buf.length,address,65001);</span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        byte[] data &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;创建DatagramPacket对象来存储服务端发送的数据</span><br><span class="line">        DatagramPacket receivedPacket &#x3D; new DatagramPacket(data,data.length);</span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        &#x2F;&#x2F;将数据取出来并打印</span><br><span class="line">        String content &#x3D; new String(receivedPacket.getData(),0,receivedPacket.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UDPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;服务端接收客户端发送的数据报</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket(65001);</span><br><span class="line">        &#x2F;&#x2F;存储从客户端收到的内容</span><br><span class="line">        byte[] buff &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;接收客户端发送的内容，并将内容封装进DatagramPacket对象中</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buff,buff.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket中获取真正存储的数据</span><br><span class="line">        byte[] data &#x3D;packet.getData();</span><br><span class="line">        &#x2F;&#x2F;将数据从二进制转化为字符串形式</span><br><span class="line">        String content &#x3D;new String(data,0,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        &#x2F;&#x2F;将要发送给客户端的数据换成二进制</span><br><span class="line">        byte[] sendedContent &#x3D;String.valueOf(content.length()).getBytes();</span><br><span class="line">        &#x2F;&#x2F;服务端给客户端发送数据报</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket对象中获取到数据的来源地址与端口号</span><br><span class="line">        DatagramPacket packetToClient &#x3D;new DatagramPacket(sendedContent,sendedContent.length,packet.getAddress(),packet.getPort());</span><br><span class="line">        socket.send(packetToClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h2&gt;&lt;p&gt;TCP在计网中的位置十分重要，很多协议的运行都是以TCP为基础来运行的，虽然TCP的开销比UDP开销大，但其实现的可靠性交付是一大特</summary>
      
    
    
    
    <category term="java基础" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/cs-net/"/>
    
    
    <category term="计算机网络" scheme="https://isbut.cn/tags/cs-net/"/>
    
    <category term="java基础" scheme="https://isbut.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式之双重校验锁的优缺点</title>
    <link href="https://isbut.cn/posts/34451/"/>
    <id>https://isbut.cn/posts/34451/</id>
    <published>2021-02-10T02:51:14.146Z</published>
    <updated>2021-02-10T03:23:26.325Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单例设计双重校验锁这种方式采用双锁机制，安全且在多线程情况下能保持高性能。但其中也有优缺点</p></blockquote><h2 id="双重校验锁代码"><a href="#双重校验锁代码" class="headerlink" title="双重校验锁代码"></a>双重校验锁代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleLock &#123;</span><br><span class="line">    </span><br><span class="line">    private  static DoubleLock doubleLock;</span><br><span class="line">    </span><br><span class="line">    private DoubleLock()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static DoubleLock getInstance()&#123;</span><br><span class="line">        if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized (DoubleLock.class)&#123;</span><br><span class="line">                if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    doubleLock &#x3D; new DoubleLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doubleLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>安全且在多线程情况下能保持高性能，第一个if判断避免了其他无用线程竞争锁来造成性能浪费，第二个if判断能拦截除第一个获得对象锁线程以外的线程。</p><p>如果不加第二次判空，我们考虑下线程A，线程B都阻塞在了获取锁的步骤上，其中A获得锁—实例化了对象—-释放锁，之后B—获得锁—实例化对象，此时违反了我们单例模式的初衷。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong></p><p><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleton &#x3D; new Singleton();</span><br></pre></td></tr></table></figure><p>该语句非原子操作，实际是三个步骤。</p><ul><li>1.给 Singleton 分配内存；</li><li>2.调用 Singleton 的构造函数来初始化成员变量；</li><li>3.将给 singleton 对象指向分配的内存空间（此时 singleton 才不为 null ）；</li></ul><p>虚拟机的<code>指令重排序</code>–&gt;</p><p>执行命令时虚拟机可能会对以上3个步骤交换位置 最后可能是132这种 分配内存并修改指针后未初始化 多线程获取时可能会出现问题。</p><p>当<code>线程A</code>进入同步方法执行<code>singleton = new Singleton();</code>代码时，恰好这三个步骤重排序后为<code>1 3 2</code>，</p><p>那么<code>步骤3</code>执行后 <code>singleton</code> 已经不为 <code>null</code> ,但是未执行<code>步骤2</code>，<code>singleton</code>对象初始化不完全，此时<code>线程B</code>执行 <code>getInstance()</code> 方法，第一步判断时 <code>singleton</code> 不为null,则直接将未完全初始化的<code>singleton</code>对象返回了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序</strong></p><p>所以使用<code>volatile</code>关键字会禁止指令重排序,可以避免这种问题。使用<code>volatile</code>关键字后使得 <code>singleton = new Singleton();</code>语句一定会按照上面拆分的步骤123来执行。</p><h2 id="另一个问题"><a href="#另一个问题" class="headerlink" title="另一个问题"></a><strong>另一个问题</strong></h2><p>单例模式并不是绝对安全的，可以通过反射来破坏，只有枚举安全类是安全的。</p><p>部分内容参考链接:<a href="https://blog.csdn.net/qq646040754/article/details/81327933">https://blog.csdn.net/qq646040754/article/details/81327933</a></p>]]></content>
    
    
    <summary type="html">单例设计双重校验锁这种方式采用双锁机制，安全且在多线程情况下能保持高性能。但其中也有优缺点</summary>
    
    
    
    <category term="java基础" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="设计模式" scheme="https://isbut.cn/categories/java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java基础" scheme="https://isbut.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="设计模式" scheme="https://isbut.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络中的4种TCP计时器详解</title>
    <link href="https://isbut.cn/posts/37509/"/>
    <id>https://isbut.cn/posts/37509/</id>
    <published>2021-01-15T14:06:20.991Z</published>
    <updated>2021-02-10T02:50:04.460Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TCP共使用以下四种计时器：重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下：</p></blockquote><h2 id="重传计时器"><a href="#重传计时器" class="headerlink" title="重传计时器"></a>重传计时器</h2><p>当TCP发送报文段时，创建该特定报文段的重传计时器。可能发生两种情况：</p><ol><li>若在计时器截止时间到之前收到了对此特定报文段的确认ACK，则撤销此计时器。</li><li>若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。</li></ol><h2 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h2><p>窗口大小通知：接收方可接收缓存的数据大小；接收方发送窗口大小通知给传送方，传送方才能发送数据，如果接收方缓存已满，会发送零窗口大小通知给发送方。</p><p>为了对付零窗口大小通知，TCP需要另一个计时器。</p><p>假定接收TCP宣布了窗口大小为零：发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。</p><p>为了解决这种死锁等待情况，TCP为每一个连接使用一个坚持计时器。当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器期限到时，发送TCP就发送探测报文段。这个报文段只有一个字节的数据，有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对方：确认已丢失，必须重传。</p><p>坚持计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将坚持计时器的值加倍和复位。发送端继续发送探测报文段，将坚持计时器设定的值加倍和复位，直到这个值增大到门限值（通常是60秒）为止。在这以后，发送端每隔60秒就发送一个探测报文段，直到窗口重新打开。</p><h2 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h2><p>保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。</p><p>假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。</p><p>要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。</p><p>若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就假定客户出了故障，因而就终止该连接。</p><h2 id="时间等待计时器"><a href="#时间等待计时器" class="headerlink" title="时间等待计时器"></a>时间等待计时器</h2><p>2MSL时间等待计时器是在连接终止期间使用，即：TCP四次挥手最后一次。</p><p>当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。</p><p>时间等待期间中连接还处于一种中间过渡状态。主要是为了让重复的FIN报文段到达目的站，将其丢弃。</p><p>这个计时器的值通常设置为一个报文段的寿命期待值的两倍。</p><p>附：TCP的四次挥手（客户端主动关闭）：</p><p>1 客户端发送断开链接请求FIN包给服务器（socket关闭发送数据的通道）；</p><p>2 服务器接收到FIN包，发送ACK包给客户端，表示同意关闭链接的请求；</p><p>3 服务器recv解堵塞，数据返回长度为0，确认客户端确实已断开链接；</p><p>4 服务器发送断开链接请求FIN包给客户端；</p><p>5 客户端收到FIN包，并发送ACK包给服务器。</p><p>6 客户端同时进入2MSL时间，若时间等待计时器（time_wait）到时，没有再次收到了服务器的FIN，证明服务器接收到自己的ACK包后已正常关闭，客户端也断开链接（socket关闭接收数据的通道）；若未到时，又收到了服务器的FIN包，证明自己发送的ACK包丢失，会再次发送，time_wait重置，直至正常。</p><h3 id="SYN泛洪攻击"><a href="#SYN泛洪攻击" class="headerlink" title="SYN泛洪攻击"></a>SYN泛洪攻击</h3><p>1.采用SYNcookies，当半开区满了之后，服务器对客户端发送的SYN报文并不直接分配半开区的连接，而是通过对源地址以及源端口号等数据进行hash运算，得到一个cookies序列号，并返回给客户端，此时客户端如果收到了并发送ACK报文，则服务器会提取里面的ack-1得到cookies，并将上述要素进行一次cookies运算，得到是否相同，同则分配，不同则拒绝</p><p>2.缩短超时时间、增大半连接的内存容量</p><p>3.使用SYN网关来转发数据包，或者使用SYN代理来与客户端通信</p>]]></content>
    
    
    <summary type="html">计算机网络中TCP连接共使用了4种计时器，分别具有不一样的功能，在连接中起着非常重要的作用。</summary>
    
    
    
    <category term="计算机基础" scheme="https://isbut.cn/categories/cs-basic/"/>
    
    <category term="计算机网络" scheme="https://isbut.cn/categories/cs-basic/cs-net/"/>
    
    
    <category term="计算机基础" scheme="https://isbut.cn/tags/cs-basic/"/>
    
    <category term="计算机网络" scheme="https://isbut.cn/tags/cs-net/"/>
    
  </entry>
  
</feed>
