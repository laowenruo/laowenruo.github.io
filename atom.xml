<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>文若君</title>
  
  <subtitle>记录一个程序员编程技术成长的知识分享博客</subtitle>
  <link href="https://isbut.cn/atom.xml" rel="self"/>
  
  <link href="https://isbut.cn/"/>
  <updated>2021-01-15T14:08:21.257Z</updated>
  <id>https://isbut.cn/</id>
  
  <author>
    <name>Ryan_Coder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络中的4种TCP计时器详解</title>
    <link href="https://isbut.cn/posts/37509/"/>
    <id>https://isbut.cn/posts/37509/</id>
    <published>2021-01-15T14:06:20.991Z</published>
    <updated>2021-01-15T14:08:21.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TCP共使用以下四种计时器：重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下：</p></blockquote><h2 id="重传计时器"><a href="#重传计时器" class="headerlink" title="重传计时器"></a>重传计时器</h2><p>当TCP发送报文段时，创建该特定报文段的重传计时器。可能发生两种情况：</p><ol><li>若在计时器截止时间到之前收到了对此特定报文段的确认ACK，则撤销此计时器。</li><li>若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。</li></ol><h2 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h2><p>窗口大小通知：接收方可接收缓存的数据大小；接收方发送窗口大小通知给传送方，传送方才能发送数据，如果接收方缓存已满，会发送零窗口大小通知给发送方。</p><p>为了对付零窗口大小通知，TCP需要另一个计时器。</p><p>假定接收TCP宣布了窗口大小为零：发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。</p><p>为了解决这种死锁等待情况，TCP为每一个连接使用一个坚持计时器。当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器期限到时，发送TCP就发送探测报文段。这个报文段只有一个字节的数据，有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对方：确认已丢失，必须重传。</p><p>坚持计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将坚持计时器的值加倍和复位。发送端继续发送探测报文段，将坚持计时器设定的值加倍和复位，直到这个值增大到门限值（通常是60秒）为止。在这以后，发送端每隔60秒就发送一个探测报文段，直到窗口重新打开。</p><h2 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h2><p>保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。</p><p>假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。</p><p>要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。</p><p>若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就假定客户出了故障，因而就终止该连接。</p><h2 id="时间等待计时器"><a href="#时间等待计时器" class="headerlink" title="时间等待计时器"></a>时间等待计时器</h2><p>2MSL时间等待计时器是在连接终止期间使用，即：TCP四次挥手最后一次。</p><p>当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。</p><p>时间等待期间中连接还处于一种中间过渡状态。主要是为了让重复的FIN报文段到达目的站，将其丢弃。</p><p>这个计时器的值通常设置为一个报文段的寿命期待值的两倍。</p><p>附：TCP的四次挥手（客户端主动关闭）：</p><p>1 客户端发送断开链接请求FIN包给服务器（socket关闭发送数据的通道）；</p><p>2 服务器接收到FIN包，发送ACK包给客户端，表示同意关闭链接的请求；</p><p>3 服务器recv解堵塞，数据返回长度为0，确认客户端确实已断开链接；</p><p>4 服务器发送断开链接请求FIN包给客户端；</p><p>5 客户端收到FIN包，并发送ACK包给服务器。</p><p>6 客户端同时进入2MSL时间，若时间等待计时器（time_wait）到时，没有再次收到了服务器的FIN，证明服务器接收到自己的ACK包后已正常关闭，客户端也断开链接（socket关闭接收数据的通道）；若未到时，又收到了服务器的FIN包，证明自己发送的ACK包丢失，会再次发送，time_wait重置，直至正常。</p><h3 id="SYN泛洪水攻击"><a href="#SYN泛洪水攻击" class="headerlink" title="SYN泛洪水攻击"></a>SYN泛洪水攻击</h3><p>1.采用SYNcookies，当半开区满了之后，服务器对客户端发送的SYN报文并不直接分配半开区的连接，而是通过对源地址以及源端口号等数据进行hash运算，得到一个cookies序列号，并返回给客户端，此时客户端如果收到了并发送ACK报文，则服务器会提取里面的ack-1得到cookies，并将上述要素进行一次cookies运算，得到是否相同，同则分配，不同则拒绝</p><p>2.缩短超时时间、增大半连接的内存容量</p><p>3.使用SYN网关来转发数据包，或者使用SYN代理来与客户端通信</p>]]></content>
    
    
    <summary type="html">计算机网络中TCP连接共使用了4种计时器，分别具有不一样的功能，在连接中起着非常重要的作用。</summary>
    
    
    
    <category term="计算机基础" scheme="https://isbut.cn/categories/cs-basic/"/>
    
    <category term="计算机网络" scheme="https://isbut.cn/categories/cs-basic/cs-net/"/>
    
    
    <category term="计算机基础" scheme="https://isbut.cn/tags/cs-basic/"/>
    
    <category term="计算机网络" scheme="https://isbut.cn/tags/cs-net/"/>
    
  </entry>
  
</feed>
