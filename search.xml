<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于TCP的一次探究</title>
      <link href="posts/45511/"/>
      <url>posts/45511/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：由于昨天面试的时候，面试官问了如果采用一次握手会出现什么问题，如何解决？当时只回答了出现的问题，并且我个人是觉得采用一次握手的话，其许多可靠性机制就已然失效，这样其实跟UDP差不多了，甚至会因为这些失效的机制而开销比UDP大，UDP首部只有8个字节，而TCP却有20个字节。</p></blockquote><h1 id="关于TCP的可靠性的保证"><a href="#关于TCP的可靠性的保证" class="headerlink" title="关于TCP的可靠性的保证"></a>关于TCP的可靠性的保证</h1><p>1、TCP具有4种计时器，分别是流量控制的时候应对零窗口的<strong>持续计时器</strong>，应对连接存活使用的<strong>保活计时器</strong>，应对四次挥手而使用的<strong>时间等待计时器</strong>（通常为2MSL，即报文段存活的两倍生命周期），应对包丢失的<strong>时间等待计时器</strong></p><p>2、我们通常关于可靠性一般指的是传输的可靠性，并不针对于信息安全的可靠性，因此我们在应用层协议的HTTP中又加了一层协议（SSL/TLS协议）形成一个信息加密协议的HTTPS，从而保证信息安全。</p><p>3、关于TCP我们经常还采用了拥塞控制、流量控制、序列号、确认应答机制、校验和等来保证了传输的可靠性，因为底层（如数据链路层以及物理层）并不能提供数据的可靠性传输，其校验和只是校验数据有无出错，出错则直接丢弃，由上层协议进行一个重发的操作。</p><h1 id="握手问题"><a href="#握手问题" class="headerlink" title="握手问题"></a>握手问题</h1><h2 id="如果采用一次握手"><a href="#如果采用一次握手" class="headerlink" title="如果采用一次握手"></a>如果采用一次握手</h2><p>1、如果采用一次握手，那么客户端向服务端发送一次连接的时候，服务端就必须为客户端分配连接资源，但是我们通过这一次握手会出现以下情况</p><ul><li>正常访问，即包能够正常发送，我们服务端收到报文，针对服务端来说：只能确认客户端具有发送能力，服务端具有接收能力。基于这些信息闭塞，我们这次连接是无法实现可靠性的，无论如何添加机制（比如客户端的接收能力是异常的或者服务端的发送能力是异常的），并且对于在网络中停留的失效报文段重新到达服务端，我们服务端也会为其分配连接资源</li><li>恶意访问，即恶意用户批量生成报文段发送给服务端，消耗服务端的连接队列，直接造成服务器的性能大幅下降</li></ul><p>2、个人觉得如果只采用一个连接的话，UDP会更优，但UDP如何实现可靠性传输，猜想也是类似于TCP一样添加机制进行</p><h2 id="如果采用二次握手"><a href="#如果采用二次握手" class="headerlink" title="如果采用二次握手"></a>如果采用二次握手</h2><p>采用二次握手出现的主要问题就是针对在网络中滞留的报文段，服务端接收了还是会建立连接，消耗了我们服务器的连接队列，如果网络十分拥挤的话，那么我们服务器资源消耗会十分严重，并且对于这些失效的报文段建立连接后，如果服务端有数据包要发送，那么就会造成一个死锁的局面（因为客户端是不理会失效连接的），服务端会因为收不到ACK确认应答而多次重发</p><h2 id="如果采用三次握手"><a href="#如果采用三次握手" class="headerlink" title="如果采用三次握手"></a>如果采用三次握手</h2><p>三次握手充分利用了TCP的可靠性机制，双方都能够确认彼此都具有接收/发送能力，故此连接是可靠的</p><h1 id="关于TCP常见的问题"><a href="#关于TCP常见的问题" class="headerlink" title="关于TCP常见的问题"></a>关于TCP常见的问题</h1><ul><li><p>DDOS（SYN泛洪攻击）：指黑客采用集群形式和工具进行一个SYN的初次建立连接请求，但后续并不理会服务端的任何回应，因为我们TCP默认收到连接建立请求的时候，会默认分配一个半开连接区，故此种攻击会造成我们服务端无法接收其他请求</p></li><li><p>应对：</p><p>1、采用SYN+cookie形式，主要是对客户端发送的报文进行一个Hash生成一个数值并且附加到包上，并且第一次连接不分配半开连接区，只有当客户端对服务端的ACK进行回应的时候，对里面的报文段再次验算，如果验证是同一个客户端，则分配半开连接区资源</p><p>2、增大半开连接区最大数量，这种形式并不是有效的解决方案</p><p>3、减小超时处理，同样也不是一个有效的解决方案</p></li></ul><h1 id="关于TCP消耗资源来说"><a href="#关于TCP消耗资源来说" class="headerlink" title="关于TCP消耗资源来说"></a>关于TCP消耗资源来说</h1><p>上文我们经常提到连接区资源或者半开连接区资源，那么这究竟是什么呢？</p><ul><li>我们都知道服务端开始监听后，每个客户端的请求都会分配一个线程进行处理，这个线程主要消耗了我们服务器端的Socket文件描述符，端口号等资源</li><li>如果你用过wireshark的话，监听会发送许多端口号不同的TCP连接，因为我们服务端的Socket其实本质上会分两个端口，一个是监听端口（web容器默认为80），一个是后续TCP建立连接分配的动态端口，一旦侦听到有客户端发送TCP链接请求，就分配一个端口（一般随机分配，且不会重复）用于建立TCP链接</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于注解注入的Spring手写实现笔记</title>
      <link href="posts/26508/"/>
      <url>posts/26508/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring手写实现注解注入笔记"><a href="#Spring手写实现注解注入笔记" class="headerlink" title="Spring手写实现注解注入笔记"></a>Spring手写实现注解注入笔记</h1><blockquote><p>本篇文章可能不是教你如何基于注解实现Spring，仅仅是本人手写实现Spring 注解注入的时候一点心得，如果发现有错误，还望告知，github链接：<a href="https://github.com/laowenruo/Spring-IOC">https://github.com/laowenruo/Spring-IOC</a>  </p></blockquote><h2 id="基于注解实现"><a href="#基于注解实现" class="headerlink" title="基于注解实现"></a>基于注解实现</h2><h3 id="了解元注解"><a href="#了解元注解" class="headerlink" title="了解元注解"></a>了解元注解</h3><ul><li>@Retention：用于注解定义上，表示注解的生命周期，常见有RetentionPolicy.RUNTIME（运行时）</li><li>@Target：用于注解定义上，常用于表示自定义的注解能用在哪个地方上，常见有ElementType.TYPE（类）</li></ul><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><ul><li>@Component：用于类，表示为IOC容器托管的Bean</li><li>@Scope：用于类，默认为单例，也可设置为原型</li><li>@Autowired：用于属性，表示向属性自动注入容器中对应类型的 bean</li><li>@Qualifier：用于属性，传递字符串，表示给这个属性注入对应名称的 bean，常与@Resource结合使用</li><li>@Value：用于属性，表示向这个属性注入某个值（基本类型）</li></ul><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;singleton&quot;</span>; <span class="comment">//默认为单例模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Value &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>由于不是自动装配，故我们要在配置文件中引入自动扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;XXX.XXX&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="扫描注解"><a href="#扫描注解" class="headerlink" title="扫描注解"></a>扫描注解</h4><blockquote><p>由于我们之前定义的 XmlBeanDefinitionReader仅仅是通过dom解析到XML中的各种属性来装入工厂，这时候我们使用注解注入时，就应该修改方法，如果扫描包的时候发现有注解属性，就优先进行注解的调用，并且这个扫描是递归扫描的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nodeList.item(i) <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          Element ele = (Element)nodeList.item(i);</span><br><span class="line">          <span class="keyword">if</span>(ele.getTagName().equals(<span class="string">&quot;component-scan&quot;</span>)) &#123;</span><br><span class="line">              basePackage = ele.getAttribute(<span class="string">&quot;base-package&quot;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(basePackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">      parseAnnotation(basePackage);   <span class="comment">//递归扫描方法</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>parseAnnotation()</code> 方法获取到目标包下所有的类，并遍历解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseAnnotation</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = getClasses(basePackage);   <span class="comment">//表示获取包下所有的类</span></span><br><span class="line">    <span class="keyword">for</span>(Class clazz : classes) &#123;</span><br><span class="line">        processAnnotationBeanDefinition(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们在学习反射的时候，是知道由getAnnotation（）方法来获取注解的，这也就是注解注入的一个重要方法了，获取注解来处理相应的操作，注入的时候就看注解的值了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationBeanDefinition</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(clazz.isAnnotationPresent(Component.class)) &#123;</span><br><span class="line">        String name = clazz.getAnnotation(Component.class).name();</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = clazz.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        String className = clazz.getName();</span><br><span class="line">        <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(clazz.isAnnotationPresent(Scope.class) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(clazz.getAnnotation(Scope.class).value())) &#123;</span><br><span class="line">            singleton = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processAnnotationProperty(clazz, beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        beanDefinition.setSingleton(singleton);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>processAnnotationProperty()</code> 则是对类的每一个属性进行判断，来确定每个属性是否需要注入等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationProperty</span><span class="params">(Class&lt;?&gt; clazz, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">        String name = field.getName();</span><br><span class="line">        <span class="keyword">if</span>(field.isAnnotationPresent(Value.class)) &#123;</span><br><span class="line">            Value valueAnnotation = field.getAnnotation(Value.class);</span><br><span class="line">            String value = valueAnnotation.value();</span><br><span class="line">            <span class="keyword">if</span>(value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 优先进行值注入</span></span><br><span class="line">                beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(field.isAnnotationPresent(Autowired.class)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(Qualifier.class)) &#123;</span><br><span class="line">                Qualifier qualifier = field.getAnnotation(Qualifier.class);</span><br><span class="line">                String ref = qualifier.value();</span><br><span class="line">                <span class="keyword">if</span>(ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of Qualifier should not be null!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String ref = field.getType().getName();</span><br><span class="line">                BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回顾下整个流程"><a href="#回顾下整个流程" class="headerlink" title="回顾下整个流程"></a>回顾下整个流程</h4><blockquote><p>其实跟前篇文章的XML解析流程差不多，只是将XML的读取换成了注解的读取</p></blockquote><ul><li>定义Application对象传入配置文件，并且对配置文件中需要扫描的包进行扫描</li><li>遍历包下的所有类，并且提取出有注解的类</li><li>对类中有需要的属性等设置到工厂中</li><li>工厂对类中的属性依次判断并且运用反射注入值，设置填充完毕属性并且实例化的bean</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h2 id="Spring的生命周期"><a href="#Spring的生命周期" class="headerlink" title="Spring的生命周期"></a>Spring的生命周期</h2><ul><li><p><img src="https://img-blog.csdn.net/20160417164808359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p></li><li><p><strong><em>spring bean从创建到销毁大致过程：实例化、属性注入、初始化、使用、销毁，</em></strong></p></li><li><p>实例化：调用构造函数为对象分配空间</p></li><li><p>属性设置：设置bean属性</p></li><li><p>如果通过Aware接口声明了依赖关系，则会注入Bean对容器基础设施层面的依赖，Aware接口是为了感知到自身的一些属性。如BeanNameAware接口，可以知道自己在容器中的名字。 如果这个Bean已经实现了BeanFactoryAware接口，可以用这个方式来获取其它Bean。</p></li><li><p>紧接着会调用BeanPostProcess的前置初始化方法postProcessBeforeInitialization，主要作用是在Spring完成实例化之后，初始化之前，对Spring容器实例化的Bean添加自定义的处理逻辑。有点类似于AOP。</p></li><li><p>如果实现了BeanFactoryPostProcessor接口的afterPropertiesSet方法，做一些属性被设定后的自定义的事情。</p></li><li><p>调用Bean自身定义的init方法，去做一些初始化相关的工作。（这个时候对象的bean才初始化）</p></li><li><p>调用BeanPostProcess的后置初始化方法，postProcessAfterInitialization去做一些bean初始化之后的自定义工作。</p></li><li><p>完成以上创建之后就可以在应用里使用这个Bean了。</p></li><li><h3 id="销毁过程："><a href="#销毁过程：" class="headerlink" title="销毁过程："></a>销毁过程：</h3><p>当Bean不再用到，便要销毁<br>1，若实现了DisposableBean接口，则会调用destroy方法；<br>2，若自定义了销毁方法，则调用自定义的销毁方法</p></li></ul><blockquote><p>部分内容参考来自<a href="https://4m.cn/F26GP">https://4m.cn/F26GP</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring手写简单MVC实现</title>
      <link href="posts/62078/"/>
      <url>posts/62078/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring手写简单MVC实现"><a href="#Spring手写简单MVC实现" class="headerlink" title="Spring手写简单MVC实现"></a>Spring手写简单MVC实现</h1><blockquote><p>本篇文章为本人在参考其他人教程的时候手动实现SpringMVC的一点心得，由别人的教程以及自己的心得整合，如果发现有错误，还望告知，github链接：<a href="https://github.com/laowenruo/Spring-IOC">https://github.com/laowenruo/Spring-IOC</a>  </p></blockquote><h2 id="SpringMVC的大致原理"><a href="#SpringMVC的大致原理" class="headerlink" title="SpringMVC的大致原理"></a>SpringMVC的大致原理</h2><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.west.cn%2Finfo%2Fupload%2F20190220%2Fbm0mjnivg0g.jpg&refer=http%3A%2F%2Fwww.west.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1619531808&t=3e7bd0425276dcf649114398e606881f"></p><ul><li>用户发送请求至前端控制器 DispatcherServlet（DispatcherServlet为MVC中最核心的类了）。</li><li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。 </li><li>DispatcherServlet 通过 HandlerAdapter 处理器适配器调用处理器。 </li><li>执行处理器（Controller，也叫后端控制器）。 </li><li>Controller 执行完成返回 ModelAndView。 </li><li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。 </li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。 </li><li>ViewReslover 解析后返回具体 View。 </li><li>DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）。 </li><li>DispatcherServlet 响应用户。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>添加servlet依赖，一切web核心都靠servlet（jsp本质也是servlet）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>添加web结构，并且在WEB-INF下添加web.xml（用来配置servlet）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>XXXX.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>web.xml解析：首先定义了DispatcherServlet的所在路径，定义得跟我们以前javaweb配置servlet一样，并且DispatcherServlet拦截全路径的（即/*），并且我们配置初始化文件，在代码中为application.properties，当然我们可以定义为其他文件，关于这个文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanPackage&#x3D;top.guoziyang.main.controller</span><br></pre></td></tr></table></figure><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;&#125;           <span class="comment">//controller注解实现处理器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;        <span class="comment">//RequestMapping实现请求映射器   </span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestParam &#123;      <span class="comment">//RequestParam实现请求参数处理</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现核心类-DispatcherServlet"><a href="#实现核心类-DispatcherServlet" class="headerlink" title="实现核心类-DispatcherServlet"></a>实现核心类-DispatcherServlet</h4><blockquote><p>init 方法首先初始化了一个 Spring 容器。其主要的功能就是读取配置文件，接着扫描目标包下所有的 Controller，最后实例化所有的 Controller，并且绑定 URL 路由。</p></blockquote><h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void init(ServletConfig config) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        xmlApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;application-annotation.xml&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    doLoadConfig(config.getInitParameter(&quot;contextConfigLocation&quot;));</span><br><span class="line">    doScanner(properties.getProperty(&quot;scanPackage&quot;));</span><br><span class="line">    doInstance();</span><br><span class="line">    initHandlerMapping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="doInstance-方法实现"><a href="#doInstance-方法实现" class="headerlink" title="doInstance() 方法实现"></a>doInstance() 方法实现</h4><blockquote><p>将上一步扫描的类中遍历一下，因为上次扫描的类都保存在属性中了，有controller注解的对象通过反射实例化，但我们上一步不是初始化了spring容器吗？这个时候如何添加bean呢？。这里给 <code>XmlApplicationContext</code> 类添加了一个 <code>refreshBeanFactory()</code> 方法，手动刷新Bean的配置，如果遇到没有初始化的（刚添加进去的）就会初始化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把类搞出来,反射来实例化(只有加 @Controller 需要实例化)</span></span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Controller.class)) &#123;</span><br><span class="line">                classes.add(clazz);</span><br><span class="line">                BeanDefinition definition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">                definition.setSingleton(<span class="keyword">true</span>);</span><br><span class="line">                definition.setBeanClassName(clazz.getName());</span><br><span class="line">                xmlApplicationContext.addNewBeanDefinition(clazz.getName(), definition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        xmlApplicationContext.refreshBeanFactory();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>refreshBeanFactory（）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    prepareBeanFactory((AbstractBeanFactory) beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我们还把符合条件的类（Controller）放在了 classes 里，这是一个 HashSet，后续在绑定 URL 的时候要用。</p><blockquote><p>在 <code>initHandlerMapping()</code> 方法中，我们将扫描对应的 Controller，找出某个 URL 应当由哪个类的哪个方法进行处理。如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (classes.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">            String baseUrl = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(RequestMapping.class)) &#123;</span><br><span class="line">                baseUrl = clazz.getAnnotation(RequestMapping.class).value();</span><br><span class="line">            &#125;</span><br><span class="line">            Method[] methods = clazz.getMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!method.isAnnotationPresent(RequestMapping.class)) <span class="keyword">continue</span>;</span><br><span class="line">                String url = method.getAnnotation(RequestMapping.class).value();</span><br><span class="line">                url = (baseUrl + <span class="string">&quot;/&quot;</span> + url).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                handlerMapping.put(url, method);</span><br><span class="line">                controllerMap.put(url, xmlApplicationContext.getBean(clazz));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义请求方法"><a href="#定义请求方法" class="headerlink" title="定义请求方法"></a>定义请求方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handlerMapping.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    String url = request.getRequestURI();</span><br><span class="line">    String contextPath = request.getContextPath();</span><br><span class="line">    url = url.replace(contextPath, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!handlerMapping.containsKey(url)) &#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;404 NOT FOUND!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Method method = handlerMapping.get(url);</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">    Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">        String requestParam = parameterTypes[i].getSimpleName();</span><br><span class="line">        <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;HttpServletRequest&quot;</span>)) &#123;</span><br><span class="line">            paramValues[i] = request;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;HttpServletResponse&quot;</span>)) &#123;</span><br><span class="line">            paramValues[i] = response;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;String&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</span><br><span class="line">                String value = Arrays.toString(param.getValue()).replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;,\\s&quot;</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                paramValues[i] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    method.invoke(controllerMap.get(url), paramValues);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    doPost(req, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//处理请求</span></span><br><span class="line">        doDispatch(req, resp);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;500!! Server Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>部分内容参考来自<a href="https://4m.cn/F26GP">https://4m.cn/F26GP</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于XML注入的Spring手写实现笔记</title>
      <link href="posts/8843/"/>
      <url>posts/8843/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring手写实现笔记"><a href="#Spring手写实现笔记" class="headerlink" title="Spring手写实现笔记"></a>Spring手写实现笔记</h1><blockquote><p>本篇文章并不是教你如何基于XML注解实现Spring，仅仅是本人手写实现Spring XML注解注入的时候一点心得，如果发现有错误，还望告知，github链接：<a href="https://github.com/laowenruo/Spring-IOC">https://github.com/laowenruo/Spring-IOC</a>  （目前仅仅实现了XML，之后还会实现其他方式）</p></blockquote><h2 id="基于XML注解实现"><a href="#基于XML注解实现" class="headerlink" title="基于XML注解实现"></a>基于XML注解实现</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p>IOC的作用就是把每个bean之间的关系交给第三方容器进行管理，bean的初始化等交给容器处理，即控制反转</p></li><li><p>所有配置文件只要是配置了全路径，我们就可以理解为其是反射得到的（如：spring.xml中配置的bean中的class属性）</p></li><li><p>SpringIOC的XML版本采用的是dom4j+反射技术实现的</p></li><li><p>反射的构造对象，肯定会走无参构造函数的。（无论构造函数是否私有）</p></li></ul><h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><h4 id="定义ApplicationContext"><a href="#定义ApplicationContext" class="headerlink" title="定义ApplicationContext"></a>定义ApplicationContext</h4><blockquote><p>因为我们使用Spring的Xml注入的时候，我们是通过ApplicationContext，即应用上下文来加载Xml后获取对象的，所以我们第一步先定义一个ApplicaitionContext的接口（为什么要定义成接口，主要是为了类的设计–单一职责原则）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类名获取对象，即ByClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名字获取对象，即ByName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义AbstractApplicationContext"><a href="#定义AbstractApplicationContext" class="headerlink" title="定义AbstractApplicationContext"></a>定义AbstractApplicationContext</h4><blockquote><p>这里实现得就有点像代理模式了，并且也要引入一个BeanFactory，因为我们获取的对象都在BeanFatory里面构造，说到这里，我们可能会想到了部分原理，即ApplicationContext传入一个XML文件—-XML文件转换为Resource流—–初始化工厂——读取Resource流中配置信息到BeanDefinition—–注册到工厂类—-由之前的工厂类创建Bean对象，并且设置各种属性等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> BeanFactory beanFactory;  <span class="comment">//工厂类，实现了工厂模式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义BeanDefinition"><a href="#定义BeanDefinition" class="headerlink" title="定义BeanDefinition"></a>定义BeanDefinition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object bean;  <span class="comment">//实例化后的对象</span></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line">    <span class="keyword">private</span> String beanClassName;</span><br><span class="line">    <span class="keyword">private</span> Boolean singleton; <span class="comment">//是否为单例模式</span></span><br><span class="line">    <span class="keyword">private</span> PropertyValues propertyValues;   <span class="comment">//这个也就是属性的键值对了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClassName = beanClassName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanClass = Class.forName(beanClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyValues == <span class="keyword">null</span>) &#123;</span><br><span class="line">            propertyValues = <span class="keyword">new</span> PropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSingleton</span><span class="params">(Boolean singleton)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.singleton = singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义ClassPathXmlApplicationContext"><a href="#定义ClassPathXmlApplicationContext" class="headerlink" title="定义ClassPathXmlApplicationContext"></a>定义ClassPathXmlApplicationContext</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">            AbstractBeanFactory beanFactory = obtainBeanFactory();</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanFactory.populateBeans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractBeanFactory <span class="title">obtainBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(location);</span><br><span class="line">        AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowiredCapableBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : beanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义XmlBeanDefinitionReader"><a href="#定义XmlBeanDefinitionReader" class="headerlink" title="定义XmlBeanDefinitionReader"></a>定义XmlBeanDefinitionReader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XML配置文件形式的Bean定义读取类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ziyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder documentBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document document = documentBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析xml document并注册bean</span></span><br><span class="line">        registerBeanDefinitions(document);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document document)</span> </span>&#123;</span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        <span class="comment">// 从文件根递归解析</span></span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        NodeList nodeList = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i ++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                processBeanDefinition((Element) node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        String name = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String className = ele.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ele.hasAttribute(<span class="string">&quot;scope&quot;</span>) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(ele.getAttribute(<span class="string">&quot;scope&quot;</span>))) &#123;</span><br><span class="line">            singleton = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processProperty(ele, beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        beanDefinition.setSingleton(singleton);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i ++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyEle.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; must specify a ref or value&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>ClassPathXmlApplication传入xml文件的路径，并且在构造函数中调用refresh方法</p></li><li><p>在这个方法中由AbstractBeanFactory定义了一个工厂类，并且调用了obtainBeanFatcory方法，在方法中调用了XmlBeanDefinitionReader类，这个类将XML转换成Resource流，并且读取了其中的key和value值，value值就是BeanDefinition</p></li><li><p>由AutowiredCapableBeanFactory（自动装配工厂类）定义一个工厂，将上述的Key和Value注册到工厂中并且返回到上面定义的工厂类，即将BeanDefinition注册到工厂类中</p></li><li><p>最后调用prepareBeanFactory方法，层层嵌套后是调用doCreateBean方法，将对象中的属性注入对象中，返回Bean到工厂中，此时BeanDefinition中的bean中就是一个实例化后、具有属性设置的对象了</p></li><li><p>之后，你就可以通过ByName或者ByClass来获取你的对象了</p><blockquote><p>部分内容参考来自<a href="https://4m.cn/F26GP">https://4m.cn/F26GP</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java集合的部分复习知识点整理</title>
      <link href="posts/1/"/>
      <url>posts/1/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Java集合的部分复习知识点整理"><a href="#关于Java集合的部分复习知识点整理" class="headerlink" title="关于Java集合的部分复习知识点整理"></a>关于Java集合的部分复习知识点整理</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ol><li><p>ArrayList本质上继承了AbstractList，而AbstractList则是继承了Collection集合类，并且Arraylist是实现了List的接口</p></li><li><p>ArrayList初始的容量，DEFAULT_CAPACITY = 10，即初始容量为10，但初始化对象的时候可以传入你自定义的容量最大容量为Interger.MaxValue-8</p></li><li><p>ArrayList的默认元素存储，是一个Object[]数组</p></li><li><p>ArrayList源码里面存在一个ensureCapacity的方法，用来确认数组的容量是否需要扩容，扩容的时候采用的是Arrays.Copyof的方法，复制元素到一个新的数组</p></li><li><p>关于ArrayList的扩容机制，达到了定义容量（不传入容量的话，即为默认容量）的时候，会动态扩容1.5倍，也是采用上述的复制方法</p></li><li><p>ArrayList其实是存在手动缩容的方法的，在源码中有叫做 trimToSize()的方法，一般是手动调用的</p></li><li><p>ArrayList中删除元素的Remove方法其实也是采用arraycopy()的方法来进行元素的移动，本质跟数组差不多</p></li><li><p>ArrayList是线程不安全的，里面没有实现线程安全的保障，多线程在访问的时候，实现的自动扩容也是造成线程不安全的一部分原因。相反，常见的Vector基本上是靠synchronized来实现线程安全的</p></li></ol><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li><p>HashMap实现了Map接口，初始容量为16，最大容量为1 &lt;&lt; 30，默认加载因子为0.75，如果自己传入初始值K，则容量为大于K的2次方整数，例如：传入10的话，则容量为16</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0bd617d78eb7474f3ff0f42d4887f16a.png"></p></li><li><p>HashMap的插入原理</p><p><img src="https://img-blog.csdnimg.cn/img_convert/af26da061524b4f0a182cf0b2749e1ce.png"></p></li><li><p>在JDK1.8之前，HashMap使用数组+链表实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间，红黑树转链表的阈值是6</p><ul><li>hash函数是通过拿到key的hashcode，然后让hashcode的高16位和低16位进行异或操作，这样设计的原因是尽可能地减小hash碰撞，其二是位运算比较高效</li></ul></li><li><p>hashmap如果采用头插法的话，在多线程的情况下会产生环，并且hashmap在多线程下也是不安全的，在JDK8之前的话，是先判断扩容再插入的，而JDK8之后则是先插入再判断是否需要扩容，扩容为扩容到原数组大小的2倍</p><ul><li><p>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小</p></li><li><p>链表转红黑树，并不是达到8个Node节点的阈值就进行转换，而是要判断一下整个数据结构中的Node数量是否大于64，大于才会转，小于就会用扩容数组的方式代替红黑树的转换</p></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li></ul><p>Java中有HashTable、Collections.synchronizedMap、以及ConcurrentHashMap可以实现线程安全的Map。</p><ol><li>HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大；</li><li>Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法内通过对象锁实现；</li><li>ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之抽象工厂模式</title>
      <link href="posts/59550/"/>
      <url>posts/59550/</url>
      
        <content type="html"><![CDATA[<blockquote><pre><code>我们都知道设计模式有五大原则</code></pre><ol><li>单一职责原则：实现类要职责单一。</li><li>开闭原则：对扩展开放，对修改关闭。</li><li>里氏替换原则：不要破坏继承体系。</li><li>接口隔离原则：设计接口的时候要精简单一。</li><li>依赖倒置原则：要面向接口编程。</li></ol><blockquote><p>了解完设计模式的五大原则后，因为简单工厂模式即是利用工厂来返回所需的实例化对象，而工厂方法则是利用实现接口后的对象工厂来返回实例化的对象。而前两种都有一定的缺点</p></blockquote><ol><li>简单工厂模式（静态工厂模式）：违反了开闭原则，耦合度较高</li><li>工厂方法模式：属于多态工厂模式，定义创建产品对象的工厂接口，将实际创建工作推迟到子类中，但调用类出现创建对象逻辑，违背单一职责原则，增加了项目开发的复杂度<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h2 id="产品接口和实现类"><a href="#产品接口和实现类" class="headerlink" title="产品接口和实现类"></a>产品接口和实现类</h2></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;  <span class="comment">//举例引擎，其他的省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighEndEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高端发动机，启动快&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowEndEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;低端发动机，启动慢&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂接口"><a href="#工厂接口" class="headerlink" title="工厂接口"></a>工厂接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Tyre <span class="title">createTyre</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Seat <span class="title">createSeat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂实现类"><a href="#工厂实现类" class="headerlink" title="工厂实现类"></a>工厂实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighEndCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HighEndEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HighEndTyre();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HighEndSeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowEndCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LowEndEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LowEndTyre();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LowEndSeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CarFactory cf = <span class="keyword">new</span> HighEndCarFactory();</span><br><span class="line">        </span><br><span class="line">        Engine engine = cf.createEngine();</span><br><span class="line">        </span><br><span class="line">        Tyre tyre = cf.createTyre();</span><br><span class="line">        </span><br><span class="line">        Seat seat = cf.createSeat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理解，高端工厂类只制造高端产品，例如高端引擎、高端轮胎以及高端座椅等，当产品族中新增几个产品，只需创建产品类以及在对应的工厂类中添加对应的方法即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用设计模式时，很难遵循五大原则和一大法则。我们使用设计模式是为了让代码具有可复用性、可扩展性和灵活性，不能一味地守着这几个规定，从而限制自己对编程的想象和发挥。因此，需要使用怎样的设计模式还得根据项目的实际需求来衡量选择。<br>这就跟我们的数据库三大范式一样，我们很难一样地遵循三大范式，有时候为了性能以及查询之类的效率，会增加点数据冗余。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化serializabel的作用及应用</title>
      <link href="posts/43483/"/>
      <url>posts/43483/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天了解了RPC调用的一些基本原理和介绍，对于在远程调用方法的时候对象的传输中序列化serializabel的作用也更加清晰，故记录下</p></blockquote><p>很多人觉得自己写得 Java 代码中，新建的 pojo 对象要实现序列化是为了要保存到硬盘上，其实呢，实现序列化和保存到硬盘上没有必然的关系。<br><img src="https://img-blog.csdnimg.cn/20210310201837920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="调用过程"></p><ul><li>很多人在初学序列化操作的时候，一般都是理解为对象通过序列化保存在磁盘上的字节流文件，后又通过字节流反向读取为对象。 </li><li>我们将 Java对象转换成公共的格式叫做序列化，将公共的格式转换成对象叫做反序列化。保存到磁盘只是序列化的一种表现形式。</li></ul><h2 id="实现序列化的原因"><a href="#实现序列化的原因" class="headerlink" title="实现序列化的原因"></a>实现序列化的原因</h2><ul><li>将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本</li><li>将对象从一个应用程序域发送至另一个应用程序域。实现serializabel接口的作用是就是可以把对象存到字节流，然后可以恢复，而网络传输的基础则是字节流，故既可以远程传输，又可以本地化恢复。（Ps:不实现序列化接口得话，服务器并不能识别其为对象类型，这是关键）<h2 id="什么时候需要序列化"><a href="#什么时候需要序列化" class="headerlink" title="什么时候需要序列化"></a>什么时候需要序列化</h2></li><li>当你想用套接字在网络上传送对象的时候；</li><li>当你想把的内存中的对象写入到硬盘的时候；</li><li>当你想通过RMI传输对象的时候；（远程调用方法，如RPC）<h2 id="Json和serializabel对比"><a href="#Json和serializabel对比" class="headerlink" title="Json和serializabel对比"></a>Json和serializabel对比</h2></li><li>长度方面，Json比serializabel小</li><li>速度方面，Json比serializabel快，但序列化算法好像并不止一种</li><li>表示方面，Json一般表示字符串，如果前端要将其处理为对象，需要额外的处理，而serializabel则直接恢复</li></ul><h2 id="Json和serializabel选择"><a href="#Json和serializabel选择" class="headerlink" title="Json和serializabel选择"></a>Json和serializabel选择</h2><ul><li><p> 序列化使用serialize，特别是对象的存储。这是其存在的意义。</p></li><li><p>与对象无关的数据存储可以使用json，如包含大量数字的数组等。只是当遇到这种情况，我们需要做的可能是重构数据库了。</p></li><li><p>数据交换时使用JSON，这也是其定义所在。</p></li><li><p>目前JSON是能用于UTF-8编码的数据</p><h2 id="Java序列化的相关知识点"><a href="#Java序列化的相关知识点" class="headerlink" title="Java序列化的相关知识点"></a>Java序列化的相关知识点</h2></li><li><p>Java序列化有两种方式，一种是实现Serializable接口。</p></li><li><p>另一种是实现Exteranlizable接口。而实现Exteranlizable接口的时候，我们需要重写writeExternal和readExternal方法，它的效率比Serializable高一些，并且可以决定哪些属性需要序列化（即使是transient修饰的），但是对大量对象，或者重复对象，则效率低。</p></li><li><p>静态变量是不会被序列化的，即使没有transient关键字修饰<br><img src="https://img-blog.csdnimg.cn/20210310204621342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="serializabel的例子"><a href="#serializabel的例子" class="headerlink" title="serializabel的例子"></a>serializabel的例子</h2><p>对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span>  //实现了序列化</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;  <span class="comment">//transient等下再讲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mailing a check to &quot;</span> + name</span><br><span class="line">                + <span class="string">&quot; &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">        e.name = <span class="string">&quot;Reyan Ali&quot;</span>;</span><br><span class="line">        e.address = <span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;</span><br><span class="line">        e.SSN = <span class="number">11122333</span>;</span><br><span class="line">        e.number = <span class="number">101</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            FileOutputStream fileOut =</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Ryan\\Desktop\\obj.ser&quot;</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">            out.writeObject(e);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.printf(<span class="string">&quot;Serialized data is saved in obj.ser&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">        &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Ryan\\Desktop\\obj.ser&quot;</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            e = (Employee) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">        &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Deserialized Employee...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address);</span><br><span class="line">        System.out.println(<span class="string">&quot;SSN: &quot;</span> + e.SSN);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number: &quot;</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>彩蛋<br><img src="https://img-blog.csdnimg.cn/2021031020524156.png" alt="在这里插入图片描述"><br>transient关键字修饰的变量反序列失败噢。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清空github仓库,而不是删除重新创建.</title>
      <link href="posts/63313/"/>
      <url>posts/63313/</url>
      
        <content type="html"><![CDATA[<p>今天由于想清空github仓库重新来过，后来不知道怎么解决，于是上网找了资料，顺便发个博文</p><p>– Remove the history from</p><p>（从中删除历史记录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure><p>– recreate the repos from the current content only</p><p>（仅从当前内容重新创建存储库）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure><p>– push to the github remote repos ensuring you overwrite history</p><p>（推送到你的远程仓库，以确保覆盖您的历史记录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:&lt;YOUR ACCOUNT&gt;&#x2F;&lt;YOUR REPOS&gt;.git</span><br><span class="line">git push -u --force origin master</span><br></pre></td></tr></table></figure><blockquote><p>来源: <a href="https://gist.github.com/stephenhardy/5470814">https://gist.github.com/stephenhardy/5470814</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM小书城整合，新手框架整合练习</title>
      <link href="posts/2860/"/>
      <url>posts/2860/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM小书城整合，新手框架整合练习"><a href="#SSM小书城整合，新手框架整合练习" class="headerlink" title="SSM小书城整合，新手框架整合练习"></a>SSM小书城整合，新手框架整合练习</h1><p>所有文件都在github（<a href="https://github.com/laowenruo/SSM-library%EF%BC%89">https://github.com/laowenruo/SSM-library）</a></p><p>本项目主要用于用于新手刚入门Spring，Mybatis,SpringMVC框架后，需要小练手整合一下，熟悉完框架之后，还是可以深入学习一下或者学下Springboot等内容(如果本项目对您有帮助，请 watch、star、fork 素质三连一波，鼓励一下作者，谢谢）<br><img src="https://img-blog.csdnimg.cn/20210308102533174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210308102533134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h2><ul><li>创建一个存放书籍数据的数据库表</li><li>文件为数据库.sql</li></ul><h2 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h2><ul><li>新建一Maven项目！ 添加web的支持</li><li>导入相关的pom依赖！</li><li>文件为pom.xml</li><li>文件为Maven资源过滤设置,静态资源导出问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;resources&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>建立基本结构和配置框架！</li></ul><h2 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h2><ul><li><p>数据库配置文件 database.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line"># &amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;123456</span><br></pre></td></tr></table></figure></li><li><p>编写MyBatis的核心配置文件  mybatis-config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;typeAliases&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;mapper resource&#x3D;&quot;com&#x2F;kuang&#x2F;dao&#x2F;BookMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写数据库对应的实体类 com.pojo.Books，可使用lombok插件！</p></li><li><p>编写Dao层的 Mapper接口！</p></li><li><p>编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p></li><li><p>编写Service层的接口和实现类</p></li></ul><h2 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h2><ul><li><p>配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；</p></li><li><p>我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p></li><li><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 配置整合mybatis --&gt;   &lt;!-- 1.关联数据库文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;   &lt;!-- 2.数据库连接池 --&gt;   &lt;!--数据库连接池       dbcp 半自动化操作 不能自动连接       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）   --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;       &lt;!-- 配置连接池属性 --&gt;       &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;       &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;       &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;       &lt;!-- c3p0连接池的私有属性 --&gt;       &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;       &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;       &lt;!-- 关闭连接后不自动commit --&gt;       &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;       &lt;!-- 获取连接超时时间 --&gt;       &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;       &lt;!-- 当获取连接失败重试次数 --&gt;       &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;       &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;   &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;   &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;       &lt;!-- 注入sqlSessionFactory --&gt;       &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;       &lt;!-- 给出需要扫描Dao接口包 --&gt;       &lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.dao&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Spring整合service层，Spring-service.xml文件编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 扫描service相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.service&quot; /&gt;   &lt;!--BookServiceImpl注入到IOC容器中--&gt;   &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.service.BookServiceImpl&quot;&gt;       &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 配置事务管理器 --&gt;   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;   &lt;/bean&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## SpringMVC层</span><br><span class="line"></span><br><span class="line">- web.xml编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;        version=&quot;4.0&quot;&gt;   &lt;!--DispatcherServlet--&gt;   &lt;servlet&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;           &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;       &lt;/init-param&gt;       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;   &lt;/servlet&gt;   &lt;servlet-mapping&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;   &lt;/servlet-mapping&gt;   &lt;!--encodingFilter--&gt;   &lt;filter&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;filter-class&gt;          org.springframework.web.filter.CharacterEncodingFilter       &lt;/filter-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;/param-name&gt;           &lt;param-value&gt;utf-8&lt;/param-value&gt;       &lt;/init-param&gt;   &lt;/filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   &lt;/filter-mapping&gt;   &lt;!--Session过期时间--&gt;   &lt;session-config&gt;       &lt;session-timeout&gt;15&lt;/session-timeout&gt;   &lt;/session-config&gt;&lt;/web-app&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- spring-mvc.xml编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/mvc   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;   &lt;!-- 配置SpringMVC --&gt;   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;   &lt;mvc:annotation-driven /&gt;   &lt;!-- 2.静态资源默认servlet配置--&gt;   &lt;mvc:default-servlet-handler/&gt;   &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;       &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;   &lt;/bean&gt;   &lt;!-- 4.扫描web相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 最后的最后，大整合</span><br><span class="line"></span><br><span class="line">- applicationContext.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;   &lt;import resource=&quot;spring-dao.xml&quot;/&gt;   &lt;import resource=&quot;spring-service.xml&quot;/&gt;   &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt;</code></pre></li></ul><h3 id="接下来就是自由的编写Controller以及视图层了，这里就不写了"><a href="#接下来就是自由的编写Controller以及视图层了，这里就不写了" class="headerlink" title="接下来就是自由的编写Controller以及视图层了，这里就不写了"></a>接下来就是自由的编写Controller以及视图层了，这里就不写了</h3><ul><li>本项目主要是基于狂神说的SpringMVC整合书城项目编写，额外的就是试了下PageHelper的插件，实现了分页</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现TCP/UDP编程</title>
      <link href="posts/8411/"/>
      <url>posts/8411/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP在计网中的位置十分重要，很多协议的运行都是以TCP为基础来运行的，虽然TCP的开销比UDP开销大，但其实现的可靠性交付是一大特点，其还具有流量控制、拥塞控制等特性，在面试中也少不了谈其三次握手、四次挥手以及其他问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class LengthCalculator extends  Thread&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line">    public LengthCalculator(Socket socket)&#123;</span><br><span class="line">        this.socket&#x3D;socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            OutputStream os &#x3D;socket.getOutputStream();</span><br><span class="line">            InputStream is &#x3D;socket.getInputStream();</span><br><span class="line">            int ch&#x3D;0;</span><br><span class="line">            byte[] buff &#x3D;new byte[1024];</span><br><span class="line">            ch&#x3D;is.read(buff);</span><br><span class="line">            String content &#x3D;new String(buff,0,ch);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">            os.write(String.valueOf(content.length()).getBytes());</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket&#x3D;new Socket(&quot;127.0.0.1&quot;,65000);</span><br><span class="line">        OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line">        InputStream in &#x3D; socket.getInputStream();</span><br><span class="line">        out.write(&quot;Hello World!&quot;.getBytes());</span><br><span class="line">        int ch&#x3D;0;</span><br><span class="line">        byte[] bytes&#x3D;new byte[1024];</span><br><span class="line">        ch&#x3D;in.read(bytes);</span><br><span class="line">        String content&#x3D;new String(bytes,0,ch);</span><br><span class="line">        System.out.println(&quot;接收到内容content:&quot;+content);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket ss &#x3D;new ServerSocket(65000);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Socket socket&#x3D;ss.accept();</span><br><span class="line">            new LengthCalculator(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP是数据报传输协议，其可传输的大小取决于数据报的大小，不像TCP协议一样受到MTU最大传输的限制，也不用像TCP一样实现报文切片等特性进行传输，但UDP的主要传输速率取决于双方的带宽，且不提供可靠性交付。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class UDPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket();</span><br><span class="line">        byte[] buf &#x3D;&quot;hello world&quot;.getBytes();</span><br><span class="line">        &#x2F;&#x2F;将IP封装为InetAddress对象</span><br><span class="line">        InetAddress address &#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);</span><br><span class="line">        &#x2F;&#x2F;将要发送数据封装成DatagramPacket对象，填写上ip地址与端口号</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buf,buf.length,address,65001);</span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        byte[] data &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;创建DatagramPacket对象来存储服务端发送的数据</span><br><span class="line">        DatagramPacket receivedPacket &#x3D; new DatagramPacket(data,data.length);</span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        &#x2F;&#x2F;将数据取出来并打印</span><br><span class="line">        String content &#x3D; new String(receivedPacket.getData(),0,receivedPacket.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UDPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;服务端接收客户端发送的数据报</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket(65001);</span><br><span class="line">        &#x2F;&#x2F;存储从客户端收到的内容</span><br><span class="line">        byte[] buff &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;接收客户端发送的内容，并将内容封装进DatagramPacket对象中</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buff,buff.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket中获取真正存储的数据</span><br><span class="line">        byte[] data &#x3D;packet.getData();</span><br><span class="line">        &#x2F;&#x2F;将数据从二进制转化为字符串形式</span><br><span class="line">        String content &#x3D;new String(data,0,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        &#x2F;&#x2F;将要发送给客户端的数据换成二进制</span><br><span class="line">        byte[] sendedContent &#x3D;String.valueOf(content.length()).getBytes();</span><br><span class="line">        &#x2F;&#x2F;服务端给客户端发送数据报</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket对象中获取到数据的来源地址与端口号</span><br><span class="line">        DatagramPacket packetToClient &#x3D;new DatagramPacket(sendedContent,sendedContent.length,packet.getAddress(),packet.getPort());</span><br><span class="line">        socket.send(packetToClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式之双重校验锁的优缺点</title>
      <link href="posts/34451/"/>
      <url>posts/34451/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例设计双重校验锁这种方式采用双锁机制，安全且在多线程情况下能保持高性能。但其中也有优缺点</p></blockquote><h2 id="双重校验锁代码"><a href="#双重校验锁代码" class="headerlink" title="双重校验锁代码"></a>双重校验锁代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleLock &#123;</span><br><span class="line">    </span><br><span class="line">    private  static DoubleLock doubleLock;</span><br><span class="line">    </span><br><span class="line">    private DoubleLock()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static DoubleLock getInstance()&#123;</span><br><span class="line">        if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized (DoubleLock.class)&#123;</span><br><span class="line">                if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    doubleLock &#x3D; new DoubleLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doubleLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>安全且在多线程情况下能保持高性能，第一个if判断避免了其他无用线程竞争锁来造成性能浪费，第二个if判断能拦截除第一个获得对象锁线程以外的线程。</p><p>如果不加第二次判空，我们考虑下线程A，线程B都阻塞在了获取锁的步骤上，其中A获得锁—实例化了对象—-释放锁，之后B—获得锁—实例化对象，此时违反了我们单例模式的初衷。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong></p><p><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleton &#x3D; new Singleton();</span><br></pre></td></tr></table></figure><p>该语句非原子操作，实际是三个步骤。</p><ul><li>1.给 Singleton 分配内存；</li><li>2.调用 Singleton 的构造函数来初始化成员变量；</li><li>3.将给 singleton 对象指向分配的内存空间（此时 singleton 才不为 null ）；</li></ul><p>虚拟机的<code>指令重排序</code>–&gt;</p><p>执行命令时虚拟机可能会对以上3个步骤交换位置 最后可能是132这种 分配内存并修改指针后未初始化 多线程获取时可能会出现问题。</p><p>当<code>线程A</code>进入同步方法执行<code>singleton = new Singleton();</code>代码时，恰好这三个步骤重排序后为<code>1 3 2</code>，</p><p>那么<code>步骤3</code>执行后 <code>singleton</code> 已经不为 <code>null</code> ,但是未执行<code>步骤2</code>，<code>singleton</code>对象初始化不完全，此时<code>线程B</code>执行 <code>getInstance()</code> 方法，第一步判断时 <code>singleton</code> 不为null,则直接将未完全初始化的<code>singleton</code>对象返回了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序</strong></p><p>所以使用<code>volatile</code>关键字会禁止指令重排序,可以避免这种问题。使用<code>volatile</code>关键字后使得 <code>singleton = new Singleton();</code>语句一定会按照上面拆分的步骤123来执行。</p><h2 id="另一个问题"><a href="#另一个问题" class="headerlink" title="另一个问题"></a><strong>另一个问题</strong></h2><p>单例模式并不是绝对安全的，可以通过反射来破坏，只有枚举安全类是安全的。</p><p>部分内容参考链接:<a href="https://blog.csdn.net/qq646040754/article/details/81327933">https://blog.csdn.net/qq646040754/article/details/81327933</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络中的4种TCP计时器详解</title>
      <link href="posts/37509/"/>
      <url>posts/37509/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TCP共使用以下四种计时器：重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下：</p></blockquote><h2 id="重传计时器"><a href="#重传计时器" class="headerlink" title="重传计时器"></a>重传计时器</h2><p>当TCP发送报文段时，创建该特定报文段的重传计时器。可能发生两种情况：</p><ol><li>若在计时器截止时间到之前收到了对此特定报文段的确认ACK，则撤销此计时器。</li><li>若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。</li></ol><h2 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h2><p>窗口大小通知：接收方可接收缓存的数据大小；接收方发送窗口大小通知给传送方，传送方才能发送数据，如果接收方缓存已满，会发送零窗口大小通知给发送方。</p><p>为了对付零窗口大小通知，TCP需要另一个计时器。</p><p>假定接收TCP宣布了窗口大小为零：发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。</p><p>为了解决这种死锁等待情况，TCP为每一个连接使用一个坚持计时器。当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器期限到时，发送TCP就发送探测报文段。这个报文段只有一个字节的数据，有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对方：确认已丢失，必须重传。</p><p>坚持计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将坚持计时器的值加倍和复位。发送端继续发送探测报文段，将坚持计时器设定的值加倍和复位，直到这个值增大到门限值（通常是60秒）为止。在这以后，发送端每隔60秒就发送一个探测报文段，直到窗口重新打开。</p><h2 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h2><p>保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。</p><p>假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。</p><p>要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。</p><p>若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就假定客户出了故障，因而就终止该连接。</p><h2 id="时间等待计时器"><a href="#时间等待计时器" class="headerlink" title="时间等待计时器"></a>时间等待计时器</h2><p>2MSL时间等待计时器是在连接终止期间使用，即：TCP四次挥手最后一次。</p><p>当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。</p><p>时间等待期间中连接还处于一种中间过渡状态。主要是为了让重复的FIN报文段到达目的站，将其丢弃。</p><p>这个计时器的值通常设置为一个报文段的寿命期待值的两倍。</p><p>附：TCP的四次挥手（客户端主动关闭）：</p><p>1 客户端发送断开链接请求FIN包给服务器（socket关闭发送数据的通道）；</p><p>2 服务器接收到FIN包，发送ACK包给客户端，表示同意关闭链接的请求；</p><p>3 服务器recv解堵塞，数据返回长度为0，确认客户端确实已断开链接；</p><p>4 服务器发送断开链接请求FIN包给客户端；</p><p>5 客户端收到FIN包，并发送ACK包给服务器。</p><p>6 客户端同时进入2MSL时间，若时间等待计时器（time_wait）到时，没有再次收到了服务器的FIN，证明服务器接收到自己的ACK包后已正常关闭，客户端也断开链接（socket关闭接收数据的通道）；若未到时，又收到了服务器的FIN包，证明自己发送的ACK包丢失，会再次发送，time_wait重置，直至正常。</p><h3 id="SYN泛洪攻击"><a href="#SYN泛洪攻击" class="headerlink" title="SYN泛洪攻击"></a>SYN泛洪攻击</h3><p>1.采用SYNcookies，当半开区满了之后，服务器对客户端发送的SYN报文并不直接分配半开区的连接，而是通过对源地址以及源端口号等数据进行hash运算，得到一个cookies序列号，并返回给客户端，此时客户端如果收到了并发送ACK报文，则服务器会提取里面的ack-1得到cookies，并将上述要素进行一次cookies运算，得到是否相同，同则分配，不同则拒绝</p><p>2.缩短超时时间、增大半连接的内存容量</p><p>3.使用SYN网关来转发数据包，或者使用SYN代理来与客户端通信</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
