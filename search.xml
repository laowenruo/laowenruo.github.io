<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>清空github仓库,而不是删除重新创建.</title>
      <link href="posts/63313/"/>
      <url>posts/63313/</url>
      
        <content type="html"><![CDATA[<p>今天由于想清空github仓库重新来过，后来不知道怎么解决，于是上网找了资料，顺便发个博文</p><p>– Remove the history from</p><p>（从中删除历史记录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure><p>– recreate the repos from the current content only</p><p>（仅从当前内容重新创建存储库）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure><p>– push to the github remote repos ensuring you overwrite history</p><p>（推送到你的远程仓库，以确保覆盖您的历史记录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:&lt;YOUR ACCOUNT&gt;&#x2F;&lt;YOUR REPOS&gt;.git</span><br><span class="line">git push -u --force origin master</span><br></pre></td></tr></table></figure><blockquote><p>来源: <a href="https://gist.github.com/stephenhardy/5470814">https://gist.github.com/stephenhardy/5470814</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM小书城整合，新手框架整合练习</title>
      <link href="posts/2860/"/>
      <url>posts/2860/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM小书城整合，新手框架整合练习"><a href="#SSM小书城整合，新手框架整合练习" class="headerlink" title="SSM小书城整合，新手框架整合练习"></a>SSM小书城整合，新手框架整合练习</h1><p>所有文件都在github（<a href="https://github.com/laowenruo/SSM-library%EF%BC%89">https://github.com/laowenruo/SSM-library）</a></p><p>本项目主要用于用于新手刚入门Spring，Mybatis,SpringMVC框架后，需要小练手整合一下，熟悉完框架之后，还是可以深入学习一下或者学下Springboot等内容(如果本项目对您有帮助，请 watch、star、fork 素质三连一波，鼓励一下作者，谢谢）<br><img src="https://img-blog.csdnimg.cn/20210308102533174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210308102533134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J5YW5fd2VucnVv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h2><ul><li>创建一个存放书籍数据的数据库表</li><li>文件为数据库.sql</li></ul><h2 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h2><ul><li>新建一Maven项目！ 添加web的支持</li><li>导入相关的pom依赖！</li><li>文件为pom.xml</li><li>文件为Maven资源过滤设置,静态资源导出问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;resources&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>建立基本结构和配置框架！</li></ul><h2 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h2><ul><li><p>数据库配置文件 database.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line"># &amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;123456</span><br></pre></td></tr></table></figure></li><li><p>编写MyBatis的核心配置文件  mybatis-config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">   &lt;typeAliases&gt;</span><br><span class="line">       &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;typeAliases&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;mapper resource&#x3D;&quot;com&#x2F;kuang&#x2F;dao&#x2F;BookMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写数据库对应的实体类 com.pojo.Books，可使用lombok插件！</p></li><li><p>编写Dao层的 Mapper接口！</p></li><li><p>编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p></li><li><p>编写Service层的接口和实现类</p></li></ul><h2 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h2><ul><li><p>配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；</p></li><li><p>我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p></li><li><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 配置整合mybatis --&gt;   &lt;!-- 1.关联数据库文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;   &lt;!-- 2.数据库连接池 --&gt;   &lt;!--数据库连接池       dbcp 半自动化操作 不能自动连接       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）   --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;       &lt;!-- 配置连接池属性 --&gt;       &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;       &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;       &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;       &lt;!-- c3p0连接池的私有属性 --&gt;       &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;       &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;       &lt;!-- 关闭连接后不自动commit --&gt;       &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;       &lt;!-- 获取连接超时时间 --&gt;       &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;       &lt;!-- 当获取连接失败重试次数 --&gt;       &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;       &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;   &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;   &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;       &lt;!-- 注入sqlSessionFactory --&gt;       &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;       &lt;!-- 给出需要扫描Dao接口包 --&gt;       &lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.dao&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Spring整合service层，Spring-service.xml文件编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 扫描service相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.service&quot; /&gt;   &lt;!--BookServiceImpl注入到IOC容器中--&gt;   &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.service.BookServiceImpl&quot;&gt;       &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 配置事务管理器 --&gt;   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;   &lt;/bean&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## SpringMVC层</span><br><span class="line"></span><br><span class="line">- web.xml编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;        version=&quot;4.0&quot;&gt;   &lt;!--DispatcherServlet--&gt;   &lt;servlet&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;           &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;       &lt;/init-param&gt;       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;   &lt;/servlet&gt;   &lt;servlet-mapping&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;   &lt;/servlet-mapping&gt;   &lt;!--encodingFilter--&gt;   &lt;filter&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;filter-class&gt;          org.springframework.web.filter.CharacterEncodingFilter       &lt;/filter-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;/param-name&gt;           &lt;param-value&gt;utf-8&lt;/param-value&gt;       &lt;/init-param&gt;   &lt;/filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   &lt;/filter-mapping&gt;   &lt;!--Session过期时间--&gt;   &lt;session-config&gt;       &lt;session-timeout&gt;15&lt;/session-timeout&gt;   &lt;/session-config&gt;&lt;/web-app&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- spring-mvc.xml编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/mvc   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;   &lt;!-- 配置SpringMVC --&gt;   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;   &lt;mvc:annotation-driven /&gt;   &lt;!-- 2.静态资源默认servlet配置--&gt;   &lt;mvc:default-servlet-handler/&gt;   &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;       &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;   &lt;/bean&gt;   &lt;!-- 4.扫描web相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;&lt;/beans&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 最后的最后，大整合</span><br><span class="line"></span><br><span class="line">- applicationContext.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;   &lt;import resource=&quot;spring-dao.xml&quot;/&gt;   &lt;import resource=&quot;spring-service.xml&quot;/&gt;   &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt;</code></pre></li></ul><h3 id="接下来就是自由的编写Controller以及视图层了，这里就不写了"><a href="#接下来就是自由的编写Controller以及视图层了，这里就不写了" class="headerlink" title="接下来就是自由的编写Controller以及视图层了，这里就不写了"></a>接下来就是自由的编写Controller以及视图层了，这里就不写了</h3><ul><li>本项目主要是基于狂神说的SpringMVC整合书城项目编写，额外的就是试了下PageHelper的插件，实现了分页</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现TCP/UDP编程</title>
      <link href="posts/8411/"/>
      <url>posts/8411/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP在计网中的位置十分重要，很多协议的运行都是以TCP为基础来运行的，虽然TCP的开销比UDP开销大，但其实现的可靠性交付是一大特点，其还具有流量控制、拥塞控制等特性，在面试中也少不了谈其三次握手、四次挥手以及其他问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class LengthCalculator extends  Thread&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line">    public LengthCalculator(Socket socket)&#123;</span><br><span class="line">        this.socket&#x3D;socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            OutputStream os &#x3D;socket.getOutputStream();</span><br><span class="line">            InputStream is &#x3D;socket.getInputStream();</span><br><span class="line">            int ch&#x3D;0;</span><br><span class="line">            byte[] buff &#x3D;new byte[1024];</span><br><span class="line">            ch&#x3D;is.read(buff);</span><br><span class="line">            String content &#x3D;new String(buff,0,ch);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">            os.write(String.valueOf(content.length()).getBytes());</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket&#x3D;new Socket(&quot;127.0.0.1&quot;,65000);</span><br><span class="line">        OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line">        InputStream in &#x3D; socket.getInputStream();</span><br><span class="line">        out.write(&quot;Hello World!&quot;.getBytes());</span><br><span class="line">        int ch&#x3D;0;</span><br><span class="line">        byte[] bytes&#x3D;new byte[1024];</span><br><span class="line">        ch&#x3D;in.read(bytes);</span><br><span class="line">        String content&#x3D;new String(bytes,0,ch);</span><br><span class="line">        System.out.println(&quot;接收到内容content:&quot;+content);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket ss &#x3D;new ServerSocket(65000);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Socket socket&#x3D;ss.accept();</span><br><span class="line">            new LengthCalculator(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP是数据报传输协议，其可传输的大小取决于数据报的大小，不像TCP协议一样受到MTU最大传输的限制，也不用像TCP一样实现报文切片等特性进行传输，但UDP的主要传输速率取决于双方的带宽，且不提供可靠性交付。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class UDPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket();</span><br><span class="line">        byte[] buf &#x3D;&quot;hello world&quot;.getBytes();</span><br><span class="line">        &#x2F;&#x2F;将IP封装为InetAddress对象</span><br><span class="line">        InetAddress address &#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);</span><br><span class="line">        &#x2F;&#x2F;将要发送数据封装成DatagramPacket对象，填写上ip地址与端口号</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buf,buf.length,address,65001);</span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        byte[] data &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;创建DatagramPacket对象来存储服务端发送的数据</span><br><span class="line">        DatagramPacket receivedPacket &#x3D; new DatagramPacket(data,data.length);</span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        &#x2F;&#x2F;将数据取出来并打印</span><br><span class="line">        String content &#x3D; new String(receivedPacket.getData(),0,receivedPacket.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UDPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;服务端接收客户端发送的数据报</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket(65001);</span><br><span class="line">        &#x2F;&#x2F;存储从客户端收到的内容</span><br><span class="line">        byte[] buff &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;接收客户端发送的内容，并将内容封装进DatagramPacket对象中</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buff,buff.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket中获取真正存储的数据</span><br><span class="line">        byte[] data &#x3D;packet.getData();</span><br><span class="line">        &#x2F;&#x2F;将数据从二进制转化为字符串形式</span><br><span class="line">        String content &#x3D;new String(data,0,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        &#x2F;&#x2F;将要发送给客户端的数据换成二进制</span><br><span class="line">        byte[] sendedContent &#x3D;String.valueOf(content.length()).getBytes();</span><br><span class="line">        &#x2F;&#x2F;服务端给客户端发送数据报</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket对象中获取到数据的来源地址与端口号</span><br><span class="line">        DatagramPacket packetToClient &#x3D;new DatagramPacket(sendedContent,sendedContent.length,packet.getAddress(),packet.getPort());</span><br><span class="line">        socket.send(packetToClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式之双重校验锁的优缺点</title>
      <link href="posts/34451/"/>
      <url>posts/34451/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例设计双重校验锁这种方式采用双锁机制，安全且在多线程情况下能保持高性能。但其中也有优缺点</p></blockquote><h2 id="双重校验锁代码"><a href="#双重校验锁代码" class="headerlink" title="双重校验锁代码"></a>双重校验锁代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleLock &#123;</span><br><span class="line">    </span><br><span class="line">    private  static DoubleLock doubleLock;</span><br><span class="line">    </span><br><span class="line">    private DoubleLock()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static DoubleLock getInstance()&#123;</span><br><span class="line">        if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized (DoubleLock.class)&#123;</span><br><span class="line">                if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    doubleLock &#x3D; new DoubleLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doubleLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>安全且在多线程情况下能保持高性能，第一个if判断避免了其他无用线程竞争锁来造成性能浪费，第二个if判断能拦截除第一个获得对象锁线程以外的线程。</p><p>如果不加第二次判空，我们考虑下线程A，线程B都阻塞在了获取锁的步骤上，其中A获得锁—实例化了对象—-释放锁，之后B—获得锁—实例化对象，此时违反了我们单例模式的初衷。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong></p><p><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleton &#x3D; new Singleton();</span><br></pre></td></tr></table></figure><p>该语句非原子操作，实际是三个步骤。</p><ul><li>1.给 Singleton 分配内存；</li><li>2.调用 Singleton 的构造函数来初始化成员变量；</li><li>3.将给 singleton 对象指向分配的内存空间（此时 singleton 才不为 null ）；</li></ul><p>虚拟机的<code>指令重排序</code>–&gt;</p><p>执行命令时虚拟机可能会对以上3个步骤交换位置 最后可能是132这种 分配内存并修改指针后未初始化 多线程获取时可能会出现问题。</p><p>当<code>线程A</code>进入同步方法执行<code>singleton = new Singleton();</code>代码时，恰好这三个步骤重排序后为<code>1 3 2</code>，</p><p>那么<code>步骤3</code>执行后 <code>singleton</code> 已经不为 <code>null</code> ,但是未执行<code>步骤2</code>，<code>singleton</code>对象初始化不完全，此时<code>线程B</code>执行 <code>getInstance()</code> 方法，第一步判断时 <code>singleton</code> 不为null,则直接将未完全初始化的<code>singleton</code>对象返回了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序</strong></p><p>所以使用<code>volatile</code>关键字会禁止指令重排序,可以避免这种问题。使用<code>volatile</code>关键字后使得 <code>singleton = new Singleton();</code>语句一定会按照上面拆分的步骤123来执行。</p><h2 id="另一个问题"><a href="#另一个问题" class="headerlink" title="另一个问题"></a><strong>另一个问题</strong></h2><p>单例模式并不是绝对安全的，可以通过反射来破坏，只有枚举安全类是安全的。</p><p>部分内容参考链接:<a href="https://blog.csdn.net/qq646040754/article/details/81327933">https://blog.csdn.net/qq646040754/article/details/81327933</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络中的4种TCP计时器详解</title>
      <link href="posts/37509/"/>
      <url>posts/37509/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TCP共使用以下四种计时器：重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下：</p></blockquote><h2 id="重传计时器"><a href="#重传计时器" class="headerlink" title="重传计时器"></a>重传计时器</h2><p>当TCP发送报文段时，创建该特定报文段的重传计时器。可能发生两种情况：</p><ol><li>若在计时器截止时间到之前收到了对此特定报文段的确认ACK，则撤销此计时器。</li><li>若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。</li></ol><h2 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h2><p>窗口大小通知：接收方可接收缓存的数据大小；接收方发送窗口大小通知给传送方，传送方才能发送数据，如果接收方缓存已满，会发送零窗口大小通知给发送方。</p><p>为了对付零窗口大小通知，TCP需要另一个计时器。</p><p>假定接收TCP宣布了窗口大小为零：发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。</p><p>为了解决这种死锁等待情况，TCP为每一个连接使用一个坚持计时器。当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器期限到时，发送TCP就发送探测报文段。这个报文段只有一个字节的数据，有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对方：确认已丢失，必须重传。</p><p>坚持计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将坚持计时器的值加倍和复位。发送端继续发送探测报文段，将坚持计时器设定的值加倍和复位，直到这个值增大到门限值（通常是60秒）为止。在这以后，发送端每隔60秒就发送一个探测报文段，直到窗口重新打开。</p><h2 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h2><p>保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。</p><p>假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。</p><p>要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。</p><p>若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就假定客户出了故障，因而就终止该连接。</p><h2 id="时间等待计时器"><a href="#时间等待计时器" class="headerlink" title="时间等待计时器"></a>时间等待计时器</h2><p>2MSL时间等待计时器是在连接终止期间使用，即：TCP四次挥手最后一次。</p><p>当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。</p><p>时间等待期间中连接还处于一种中间过渡状态。主要是为了让重复的FIN报文段到达目的站，将其丢弃。</p><p>这个计时器的值通常设置为一个报文段的寿命期待值的两倍。</p><p>附：TCP的四次挥手（客户端主动关闭）：</p><p>1 客户端发送断开链接请求FIN包给服务器（socket关闭发送数据的通道）；</p><p>2 服务器接收到FIN包，发送ACK包给客户端，表示同意关闭链接的请求；</p><p>3 服务器recv解堵塞，数据返回长度为0，确认客户端确实已断开链接；</p><p>4 服务器发送断开链接请求FIN包给客户端；</p><p>5 客户端收到FIN包，并发送ACK包给服务器。</p><p>6 客户端同时进入2MSL时间，若时间等待计时器（time_wait）到时，没有再次收到了服务器的FIN，证明服务器接收到自己的ACK包后已正常关闭，客户端也断开链接（socket关闭接收数据的通道）；若未到时，又收到了服务器的FIN包，证明自己发送的ACK包丢失，会再次发送，time_wait重置，直至正常。</p><h3 id="SYN泛洪攻击"><a href="#SYN泛洪攻击" class="headerlink" title="SYN泛洪攻击"></a>SYN泛洪攻击</h3><p>1.采用SYNcookies，当半开区满了之后，服务器对客户端发送的SYN报文并不直接分配半开区的连接，而是通过对源地址以及源端口号等数据进行hash运算，得到一个cookies序列号，并返回给客户端，此时客户端如果收到了并发送ACK报文，则服务器会提取里面的ack-1得到cookies，并将上述要素进行一次cookies运算，得到是否相同，同则分配，不同则拒绝</p><p>2.缩短超时时间、增大半连接的内存容量</p><p>3.使用SYN网关来转发数据包，或者使用SYN代理来与客户端通信</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
