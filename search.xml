<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java实现TCP/UDP编程</title>
      <link href="posts/8411/"/>
      <url>posts/8411/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP在计网中的位置十分重要，很多协议的运行都是以TCP为基础来运行的，虽然TCP的开销比UDP开销大，但其实现的可靠性交付是一大特点，其还具有流量控制、拥塞控制等特性，在面试中也少不了谈其三次握手、四次挥手以及其他问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class LengthCalculator extends  Thread&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line">    public LengthCalculator(Socket socket)&#123;</span><br><span class="line">        this.socket&#x3D;socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            OutputStream os &#x3D;socket.getOutputStream();</span><br><span class="line">            InputStream is &#x3D;socket.getInputStream();</span><br><span class="line">            int ch&#x3D;0;</span><br><span class="line">            byte[] buff &#x3D;new byte[1024];</span><br><span class="line">            ch&#x3D;is.read(buff);</span><br><span class="line">            String content &#x3D;new String(buff,0,ch);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">            os.write(String.valueOf(content.length()).getBytes());</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket&#x3D;new Socket(&quot;127.0.0.1&quot;,65000);</span><br><span class="line">        OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line">        InputStream in &#x3D; socket.getInputStream();</span><br><span class="line">        out.write(&quot;Hello World!&quot;.getBytes());</span><br><span class="line">        int ch&#x3D;0;</span><br><span class="line">        byte[] bytes&#x3D;new byte[1024];</span><br><span class="line">        ch&#x3D;in.read(bytes);</span><br><span class="line">        String content&#x3D;new String(bytes,0,ch);</span><br><span class="line">        System.out.println(&quot;接收到内容content:&quot;+content);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket ss &#x3D;new ServerSocket(65000);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Socket socket&#x3D;ss.accept();</span><br><span class="line">            new LengthCalculator(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP是数据报传输协议，其可传输的大小取决于数据报的大小，不像TCP协议一样受到MTU最大传输的限制，也不用像TCP一样实现报文切片等特性进行传输，但UDP的主要传输速率取决于双方的带宽，且不提供可靠性交付。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class UDPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket();</span><br><span class="line">        byte[] buf &#x3D;&quot;hello world&quot;.getBytes();</span><br><span class="line">        &#x2F;&#x2F;将IP封装为InetAddress对象</span><br><span class="line">        InetAddress address &#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);</span><br><span class="line">        &#x2F;&#x2F;将要发送数据封装成DatagramPacket对象，填写上ip地址与端口号</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buf,buf.length,address,65001);</span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        byte[] data &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;创建DatagramPacket对象来存储服务端发送的数据</span><br><span class="line">        DatagramPacket receivedPacket &#x3D; new DatagramPacket(data,data.length);</span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        &#x2F;&#x2F;将数据取出来并打印</span><br><span class="line">        String content &#x3D; new String(receivedPacket.getData(),0,receivedPacket.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UDPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;服务端接收客户端发送的数据报</span><br><span class="line">        DatagramSocket socket &#x3D;new DatagramSocket(65001);</span><br><span class="line">        &#x2F;&#x2F;存储从客户端收到的内容</span><br><span class="line">        byte[] buff &#x3D;new byte[100];</span><br><span class="line">        &#x2F;&#x2F;接收客户端发送的内容，并将内容封装进DatagramPacket对象中</span><br><span class="line">        DatagramPacket packet &#x3D;new DatagramPacket(buff,buff.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket中获取真正存储的数据</span><br><span class="line">        byte[] data &#x3D;packet.getData();</span><br><span class="line">        &#x2F;&#x2F;将数据从二进制转化为字符串形式</span><br><span class="line">        String content &#x3D;new String(data,0,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        &#x2F;&#x2F;将要发送给客户端的数据换成二进制</span><br><span class="line">        byte[] sendedContent &#x3D;String.valueOf(content.length()).getBytes();</span><br><span class="line">        &#x2F;&#x2F;服务端给客户端发送数据报</span><br><span class="line">        &#x2F;&#x2F;从DatagramPacket对象中获取到数据的来源地址与端口号</span><br><span class="line">        DatagramPacket packetToClient &#x3D;new DatagramPacket(sendedContent,sendedContent.length,packet.getAddress(),packet.getPort());</span><br><span class="line">        socket.send(packetToClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式之双重校验锁的优缺点</title>
      <link href="posts/34451/"/>
      <url>posts/34451/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例设计双重校验锁这种方式采用双锁机制，安全且在多线程情况下能保持高性能。但其中也有优缺点</p></blockquote><h2 id="双重校验锁代码"><a href="#双重校验锁代码" class="headerlink" title="双重校验锁代码"></a>双重校验锁代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleLock &#123;</span><br><span class="line">    </span><br><span class="line">    private  static DoubleLock doubleLock;</span><br><span class="line">    </span><br><span class="line">    private DoubleLock()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static DoubleLock getInstance()&#123;</span><br><span class="line">        if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized (DoubleLock.class)&#123;</span><br><span class="line">                if (doubleLock &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    doubleLock &#x3D; new DoubleLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doubleLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>安全且在多线程情况下能保持高性能，第一个if判断避免了其他无用线程竞争锁来造成性能浪费，第二个if判断能拦截除第一个获得对象锁线程以外的线程。</p><p>如果不加第二次判空，我们考虑下线程A，线程B都阻塞在了获取锁的步骤上，其中A获得锁—实例化了对象—-释放锁，之后B—获得锁—实例化对象，此时违反了我们单例模式的初衷。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong></p><p><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleton &#x3D; new Singleton();</span><br></pre></td></tr></table></figure><p>该语句非原子操作，实际是三个步骤。</p><ul><li>1.给 Singleton 分配内存；</li><li>2.调用 Singleton 的构造函数来初始化成员变量；</li><li>3.将给 singleton 对象指向分配的内存空间（此时 singleton 才不为 null ）；</li></ul><p>虚拟机的<code>指令重排序</code>–&gt;</p><p>执行命令时虚拟机可能会对以上3个步骤交换位置 最后可能是132这种 分配内存并修改指针后未初始化 多线程获取时可能会出现问题。</p><p>当<code>线程A</code>进入同步方法执行<code>singleton = new Singleton();</code>代码时，恰好这三个步骤重排序后为<code>1 3 2</code>，</p><p>那么<code>步骤3</code>执行后 <code>singleton</code> 已经不为 <code>null</code> ,但是未执行<code>步骤2</code>，<code>singleton</code>对象初始化不完全，此时<code>线程B</code>执行 <code>getInstance()</code> 方法，第一步判断时 <code>singleton</code> 不为null,则直接将未完全初始化的<code>singleton</code>对象返回了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序</strong></p><p>所以使用<code>volatile</code>关键字会禁止指令重排序,可以避免这种问题。使用<code>volatile</code>关键字后使得 <code>singleton = new Singleton();</code>语句一定会按照上面拆分的步骤123来执行。</p><h2 id="另一个问题"><a href="#另一个问题" class="headerlink" title="另一个问题"></a><strong>另一个问题</strong></h2><p>单例模式并不是绝对安全的，可以通过反射来破坏，只有枚举安全类是安全的。</p><p>部分内容参考链接:<a href="https://blog.csdn.net/qq646040754/article/details/81327933">https://blog.csdn.net/qq646040754/article/details/81327933</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络中的4种TCP计时器详解</title>
      <link href="posts/37509/"/>
      <url>posts/37509/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TCP共使用以下四种计时器：重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下：</p></blockquote><h2 id="重传计时器"><a href="#重传计时器" class="headerlink" title="重传计时器"></a>重传计时器</h2><p>当TCP发送报文段时，创建该特定报文段的重传计时器。可能发生两种情况：</p><ol><li>若在计时器截止时间到之前收到了对此特定报文段的确认ACK，则撤销此计时器。</li><li>若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。</li></ol><h2 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h2><p>窗口大小通知：接收方可接收缓存的数据大小；接收方发送窗口大小通知给传送方，传送方才能发送数据，如果接收方缓存已满，会发送零窗口大小通知给发送方。</p><p>为了对付零窗口大小通知，TCP需要另一个计时器。</p><p>假定接收TCP宣布了窗口大小为零：发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。</p><p>为了解决这种死锁等待情况，TCP为每一个连接使用一个坚持计时器。当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器期限到时，发送TCP就发送探测报文段。这个报文段只有一个字节的数据，有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对方：确认已丢失，必须重传。</p><p>坚持计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将坚持计时器的值加倍和复位。发送端继续发送探测报文段，将坚持计时器设定的值加倍和复位，直到这个值增大到门限值（通常是60秒）为止。在这以后，发送端每隔60秒就发送一个探测报文段，直到窗口重新打开。</p><h2 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h2><p>保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。</p><p>假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。</p><p>要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。</p><p>若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就假定客户出了故障，因而就终止该连接。</p><h2 id="时间等待计时器"><a href="#时间等待计时器" class="headerlink" title="时间等待计时器"></a>时间等待计时器</h2><p>2MSL时间等待计时器是在连接终止期间使用，即：TCP四次挥手最后一次。</p><p>当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。</p><p>时间等待期间中连接还处于一种中间过渡状态。主要是为了让重复的FIN报文段到达目的站，将其丢弃。</p><p>这个计时器的值通常设置为一个报文段的寿命期待值的两倍。</p><p>附：TCP的四次挥手（客户端主动关闭）：</p><p>1 客户端发送断开链接请求FIN包给服务器（socket关闭发送数据的通道）；</p><p>2 服务器接收到FIN包，发送ACK包给客户端，表示同意关闭链接的请求；</p><p>3 服务器recv解堵塞，数据返回长度为0，确认客户端确实已断开链接；</p><p>4 服务器发送断开链接请求FIN包给客户端；</p><p>5 客户端收到FIN包，并发送ACK包给服务器。</p><p>6 客户端同时进入2MSL时间，若时间等待计时器（time_wait）到时，没有再次收到了服务器的FIN，证明服务器接收到自己的ACK包后已正常关闭，客户端也断开链接（socket关闭接收数据的通道）；若未到时，又收到了服务器的FIN包，证明自己发送的ACK包丢失，会再次发送，time_wait重置，直至正常。</p><h3 id="SYN泛洪攻击"><a href="#SYN泛洪攻击" class="headerlink" title="SYN泛洪攻击"></a>SYN泛洪攻击</h3><p>1.采用SYNcookies，当半开区满了之后，服务器对客户端发送的SYN报文并不直接分配半开区的连接，而是通过对源地址以及源端口号等数据进行hash运算，得到一个cookies序列号，并返回给客户端，此时客户端如果收到了并发送ACK报文，则服务器会提取里面的ack-1得到cookies，并将上述要素进行一次cookies运算，得到是否相同，同则分配，不同则拒绝</p><p>2.缩短超时时间、增大半连接的内存容量</p><p>3.使用SYN网关来转发数据包，或者使用SYN代理来与客户端通信</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
